{"version":3,"file":"urql-exchange-graphcache-default-storage.min.js","sources":["../src/default-storage/index.ts"],"sourcesContent":["import { SerializedEntries, SerializedRequest, StorageAdapter } from '../types';\n\nconst getRequestPromise = <T>(request: IDBRequest<T>): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    request.onerror = () => {\n      reject(request.error);\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n  });\n};\n\nconst getTransactionPromise = (transaction: IDBTransaction): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    transaction.onerror = () => {\n      reject(transaction.error);\n    };\n\n    transaction.oncomplete = resolve;\n  });\n};\n\nexport interface StorageOptions {\n  idbName?: string;\n  maxAge?: number;\n}\n\nexport interface DefaultStorage extends StorageAdapter {\n  clear(): Promise<any>;\n}\n\nexport const makeDefaultStorage = (opts?: StorageOptions): DefaultStorage => {\n  if (!opts) opts = {};\n\n  let callback: (() => void) | undefined;\n\n  const DB_NAME = opts.idbName || 'graphcache-v4';\n  const ENTRIES_STORE_NAME = 'entries';\n  const METADATA_STORE_NAME = 'metadata';\n\n  let batch: Record<string, string | undefined> = Object.create(null);\n  const timestamp = Math.floor(new Date().valueOf() / (1000 * 60 * 60 * 24));\n  const maxAge = timestamp - (opts.maxAge || 7);\n\n  const req = indexedDB.open(DB_NAME, 1);\n  const database$ = getRequestPromise(req);\n\n  req.onupgradeneeded = () => {\n    req.result.createObjectStore(ENTRIES_STORE_NAME);\n    req.result.createObjectStore(METADATA_STORE_NAME);\n  };\n\n  const serializeEntry = (entry: string): string => entry.replace(/:/g, '%3a');\n\n  const deserializeEntry = (entry: string): string =>\n    entry.replace(/%3a/g, ':');\n\n  const serializeBatch = (): string => {\n    let data = '';\n    for (const key in batch) {\n      const value = batch[key];\n      data += serializeEntry(key);\n      data += ':';\n      if (value) data += serializeEntry(value);\n      data += ':';\n    }\n\n    return data;\n  };\n\n  const deserializeBatch = (input: string) => {\n    const data = {};\n    let char = '',\n      key = '',\n      entry = '',\n      mode = 0,\n      index = 0;\n\n    while (index < input.length) {\n      entry = '';\n      while ((char = input[index++]) !== ':' && char) {\n        entry += char;\n      }\n\n      if (mode) {\n        data[key] = deserializeEntry(entry) || undefined;\n        mode = 0;\n      } else {\n        key = deserializeEntry(entry);\n        mode = 1;\n      }\n    }\n\n    return data;\n  };\n\n  return {\n    clear() {\n      return database$.then(database => {\n        const transaction = database.transaction(\n          [METADATA_STORE_NAME, ENTRIES_STORE_NAME],\n          'readwrite'\n        );\n        transaction.objectStore(METADATA_STORE_NAME).clear();\n        transaction.objectStore(ENTRIES_STORE_NAME).clear();\n        batch = Object.create(null);\n        return getTransactionPromise(transaction);\n      });\n    },\n\n    readMetadata(): Promise<null | SerializedRequest[]> {\n      return database$.then(\n        database => {\n          return getRequestPromise<SerializedRequest[]>(\n            database\n              .transaction(METADATA_STORE_NAME, 'readonly')\n              .objectStore(METADATA_STORE_NAME)\n              .get(METADATA_STORE_NAME)\n          );\n        },\n        () => null\n      );\n    },\n\n    writeMetadata(metadata: SerializedRequest[]) {\n      database$.then(\n        database => {\n          return getRequestPromise(\n            database\n              .transaction(METADATA_STORE_NAME, 'readwrite')\n              .objectStore(METADATA_STORE_NAME)\n              .put(metadata, METADATA_STORE_NAME)\n          );\n        },\n        () => {\n          /* noop */\n        }\n      );\n    },\n\n    writeData(entries: SerializedEntries): Promise<void> {\n      Object.assign(batch, entries);\n      const toUndefined = () => undefined;\n\n      return database$\n        .then(database => {\n          return getRequestPromise(\n            database\n              .transaction(ENTRIES_STORE_NAME, 'readwrite')\n              .objectStore(ENTRIES_STORE_NAME)\n              .put(serializeBatch(), timestamp)\n          );\n        })\n        .then(toUndefined, toUndefined);\n    },\n\n    readData(): Promise<SerializedEntries> {\n      const chunks: string[] = [];\n      return database$\n        .then(database => {\n          const transaction = database.transaction(\n            ENTRIES_STORE_NAME,\n            'readwrite'\n          );\n\n          const store = transaction.objectStore(ENTRIES_STORE_NAME);\n          const request = (store.openKeyCursor || store.openCursor).call(store);\n\n          request.onsuccess = function () {\n            if (this.result) {\n              const { key } = this.result;\n              if (typeof key !== 'number' || key < maxAge) {\n                store.delete(key);\n              } else {\n                const request = store.get(key);\n                const index = chunks.length;\n                chunks.push('');\n                request.onsuccess = () => {\n                  const result = '' + request.result;\n                  if (key === timestamp)\n                    Object.assign(batch, deserializeBatch(result));\n                  chunks[index] = result;\n                };\n              }\n\n              this.result.continue();\n            }\n          };\n\n          return getTransactionPromise(transaction);\n        })\n        .then(\n          () => deserializeBatch(chunks.join('')),\n          () => batch\n        );\n    },\n\n    onOnline(cb: () => void) {\n      if (callback) {\n        window.removeEventListener('online', callback);\n        callback = undefined;\n      }\n\n      window.addEventListener(\n        'online',\n        (callback = () => {\n          cb();\n        })\n      );\n    },\n  };\n};\n"],"names":["request","error","reject","onerror","onsuccess","transaction","oncomplete","resolve","opts","database$","timestamp","onupgradeneeded","getRequestPromise","req","result","createObjectStore","ENTRIES_STORE_NAME","deserializeEntry","entry","replace","deserializeBatch","input","key","mode","index","char","data","undefined","clear","batch","objectStore","METADATA_STORE_NAME","getTransactionPromise","Object","create","then","database","toUndefined","entries","serializeEntry","value","readData","store","call","maxAge","push","chunks","assign","window","removeEventListener","callback"],"mappings":"2DAIIA,EAAAA,OACEA,SAAAC,CAAAA,EAAAC,OADFC,QAAA,mBAIAC,UAAA,qBAQAC,EAAAA,OACEA,SAAAA,CAAAA,EAAAH,OADFC,QAAA,iBAFJE,EAAAC,WAAAC,gCAsBEC,cAEAA,EAAA,6HASAC,EAAAC,aAAA,yBAEAC,EAAAC,EAAAC,GAEEA,EAAAA,qBAFFA,EAAAC,OAAAC,kBAAAC,kCAOA,IAAAC,EAAAC,GAAAA,EAAAA,QAAAC,KAAA,kCAkBEC,EAAAC,QAAAC,IAAAA,EAAA,GAAAJ,KAAAK,KAAAC,EAAA,SAMA,eAIG,IAFDN,EAAAO,GAEC,OAAAA,EAAAJ,EAAAG,OAAAC,WAKMC,EAAAJ,GAAAL,EAAAC,SAAAS,EACLL,EAAAL,IAEDK,EAAAL,EAAAC,GACFK,EAAA,aAOC,OACEK,MAAAvB,8DAMAwB,EAAAC,YAAAC,GAAAH,QACAvB,EAAA2B,YAAAA,GAAAJ,QARFC,EAAAI,OAAAC,OAAA,+BAqBEzB,EARF0B,MAAAC,2JAcA,uBAiBAH,OAAAI,OAAAA,EAAAC,GAEA,MAAA,OAAA,OAAA7B,QASG4B,2DA9FL,IAAAX,EAAA,GAEEA,QAAAa,KAAAA,EAAAA,YAEAb,KAAWJ,UAEZkB,IAAAd,GAAAa,EAAAC,yCA6FCC,uCAQI,IAAAzC,EAAA0C,EAAArC,YAAAW,EAAA2B,8EAIIvC,UAAA,WAAAkB,GAAAA,KAAAA,OAAAA,CAAA,IAAAA,mBAGC,GAAM,iBAAAA,GAAAA,EAAAsB,mBAEL,IAAApB,EAAAkB,MAAApB,cAEAtB,EAAA6C,KAAA,qBAIEC,MAAA,KAAAhC,OAJFQ,IAAAZ,GAAAuB,OAAAc,OAAAlB,EAAAT,EAAAN,IAMDgC,EAAAtB,GAAAV,uEAgBPkC,SAAAA,OAEDA,OAAAC,oBAAA,SAAAC"}