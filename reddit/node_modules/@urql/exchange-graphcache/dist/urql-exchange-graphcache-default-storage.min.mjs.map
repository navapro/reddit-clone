{"version":3,"file":"urql-exchange-graphcache-default-storage.min.mjs","sources":["../src/default-storage/index.ts"],"sourcesContent":["import { SerializedEntries, SerializedRequest, StorageAdapter } from '../types';\n\nconst getRequestPromise = <T>(request: IDBRequest<T>): Promise<T> => {\n  return new Promise((resolve, reject) => {\n    request.onerror = () => {\n      reject(request.error);\n    };\n\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n  });\n};\n\nconst getTransactionPromise = (transaction: IDBTransaction): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    transaction.onerror = () => {\n      reject(transaction.error);\n    };\n\n    transaction.oncomplete = resolve;\n  });\n};\n\nexport interface StorageOptions {\n  idbName?: string;\n  maxAge?: number;\n}\n\nexport interface DefaultStorage extends StorageAdapter {\n  clear(): Promise<any>;\n}\n\nexport const makeDefaultStorage = (opts?: StorageOptions): DefaultStorage => {\n  if (!opts) opts = {};\n\n  let callback: (() => void) | undefined;\n\n  const DB_NAME = opts.idbName || 'graphcache-v4';\n  const ENTRIES_STORE_NAME = 'entries';\n  const METADATA_STORE_NAME = 'metadata';\n\n  let batch: Record<string, string | undefined> = Object.create(null);\n  const timestamp = Math.floor(new Date().valueOf() / (1000 * 60 * 60 * 24));\n  const maxAge = timestamp - (opts.maxAge || 7);\n\n  const req = indexedDB.open(DB_NAME, 1);\n  const database$ = getRequestPromise(req);\n\n  req.onupgradeneeded = () => {\n    req.result.createObjectStore(ENTRIES_STORE_NAME);\n    req.result.createObjectStore(METADATA_STORE_NAME);\n  };\n\n  const serializeEntry = (entry: string): string => entry.replace(/:/g, '%3a');\n\n  const deserializeEntry = (entry: string): string =>\n    entry.replace(/%3a/g, ':');\n\n  const serializeBatch = (): string => {\n    let data = '';\n    for (const key in batch) {\n      const value = batch[key];\n      data += serializeEntry(key);\n      data += ':';\n      if (value) data += serializeEntry(value);\n      data += ':';\n    }\n\n    return data;\n  };\n\n  const deserializeBatch = (input: string) => {\n    const data = {};\n    let char = '',\n      key = '',\n      entry = '',\n      mode = 0,\n      index = 0;\n\n    while (index < input.length) {\n      entry = '';\n      while ((char = input[index++]) !== ':' && char) {\n        entry += char;\n      }\n\n      if (mode) {\n        data[key] = deserializeEntry(entry) || undefined;\n        mode = 0;\n      } else {\n        key = deserializeEntry(entry);\n        mode = 1;\n      }\n    }\n\n    return data;\n  };\n\n  return {\n    clear() {\n      return database$.then(database => {\n        const transaction = database.transaction(\n          [METADATA_STORE_NAME, ENTRIES_STORE_NAME],\n          'readwrite'\n        );\n        transaction.objectStore(METADATA_STORE_NAME).clear();\n        transaction.objectStore(ENTRIES_STORE_NAME).clear();\n        batch = Object.create(null);\n        return getTransactionPromise(transaction);\n      });\n    },\n\n    readMetadata(): Promise<null | SerializedRequest[]> {\n      return database$.then(\n        database => {\n          return getRequestPromise<SerializedRequest[]>(\n            database\n              .transaction(METADATA_STORE_NAME, 'readonly')\n              .objectStore(METADATA_STORE_NAME)\n              .get(METADATA_STORE_NAME)\n          );\n        },\n        () => null\n      );\n    },\n\n    writeMetadata(metadata: SerializedRequest[]) {\n      database$.then(\n        database => {\n          return getRequestPromise(\n            database\n              .transaction(METADATA_STORE_NAME, 'readwrite')\n              .objectStore(METADATA_STORE_NAME)\n              .put(metadata, METADATA_STORE_NAME)\n          );\n        },\n        () => {\n          /* noop */\n        }\n      );\n    },\n\n    writeData(entries: SerializedEntries): Promise<void> {\n      Object.assign(batch, entries);\n      const toUndefined = () => undefined;\n\n      return database$\n        .then(database => {\n          return getRequestPromise(\n            database\n              .transaction(ENTRIES_STORE_NAME, 'readwrite')\n              .objectStore(ENTRIES_STORE_NAME)\n              .put(serializeBatch(), timestamp)\n          );\n        })\n        .then(toUndefined, toUndefined);\n    },\n\n    readData(): Promise<SerializedEntries> {\n      const chunks: string[] = [];\n      return database$\n        .then(database => {\n          const transaction = database.transaction(\n            ENTRIES_STORE_NAME,\n            'readwrite'\n          );\n\n          const store = transaction.objectStore(ENTRIES_STORE_NAME);\n          const request = (store.openKeyCursor || store.openCursor).call(store);\n\n          request.onsuccess = function () {\n            if (this.result) {\n              const { key } = this.result;\n              if (typeof key !== 'number' || key < maxAge) {\n                store.delete(key);\n              } else {\n                const request = store.get(key);\n                const index = chunks.length;\n                chunks.push('');\n                request.onsuccess = () => {\n                  const result = '' + request.result;\n                  if (key === timestamp)\n                    Object.assign(batch, deserializeBatch(result));\n                  chunks[index] = result;\n                };\n              }\n\n              this.result.continue();\n            }\n          };\n\n          return getTransactionPromise(transaction);\n        })\n        .then(\n          () => deserializeBatch(chunks.join('')),\n          () => batch\n        );\n    },\n\n    onOnline(cb: () => void) {\n      if (callback) {\n        window.removeEventListener('online', callback);\n        callback = undefined;\n      }\n\n      window.addEventListener(\n        'online',\n        (callback = () => {\n          cb();\n        })\n      );\n    },\n  };\n};\n"],"names":["getRequestPromise","request","onerror","reject","error","onsuccess","resolve","result","getTransactionPromise","transaction","oncomplete","makeDefaultStorage","opts","callback","DB_NAME","idbName","database$","req","onupgradeneeded","createObjectStore","ENTRIES_STORE_NAME","METADATA_STORE_NAME","serializeEntry","entry","replace","deserializeEntry","deserializeBatch","input","char","key","mode","index","length","data","then","database","batch","Object","create","get","writeMetadata","metadata","put","writeData","entries","assign","toUndefined","value","serializeBatch","timestamp","store","openKeyCursor","openCursor","call","this","delete","chunks","push","continue","join","onOnline","cb","window","removeEventListener"],"mappings":"AAEA,IAAAA,EAAAC,wBAEIA,EAAAC,QAAA,KACEC,EAAAF,EAAAG,QAGFH,EAAAI,UAAA,KACEC,EAAAL,EAAAM,YAKNC,EAAAC,wBAEIA,EAAAP,QAAA,KACEC,EAAAM,EAAAL,QAGFK,EAAAC,WAAAJ,KAaJK,EAAAC,IAGE,IAAAC,EAFAD,UAIA,IAAAE,EAAAF,EAAAG,SAAA,gJASAC,EAAAhB,EAAAiB,GAEAA,EAAAC,gBAAA,KACED,EAAAV,OAAAY,kBAAAC,GACAH,EAAAV,OAAAY,kBAAAE,IAGF,IAAAC,EAAAC,GAAAA,EAAAC,QAAA,KAAA,OAEAC,EAAAF,GAAAA,EAAAC,QAAA,OAAA,KAgBAE,EAAAC,IAQE,aANAC,EAAA,GAAAC,EAAA,GAAAN,EAAA,GAAAO,EAAA,EAAAC,EAAA,EAMAA,EAAAJ,EAAAK,QAAA,CAEE,SAAA,OAAAJ,EAAAD,EAAAI,OAAAH,QAIAE,2BAIED,EAAAJ,EAAAF,QAKJ,OAAAU,oBAKEjB,EAAAkB,MAAAC,IACE,IAAA1B,EAAA0B,EAAA1B,YAAA,CAAAY,EAAAD,GAAA,aAOA,yDADAgB,EAAAC,OAAAC,OAAA,MACA9B,EAAAC,uBAKFO,EAAAkB,MAAAC,OAIS1B,YAAAY,EAAA,2BAEAkB,IAAAlB,MAEP,IAAA,OAKJmB,cAAAC,GACEzB,EAAAkB,MAAAC,OAIS1B,YAAAY,EAAA,4BAEAqB,IAAAD,EAAApB,gBASXsB,UAAAC,GACEP,OAAAQ,OAAAT,EAAAQ,GACA,IAAAE,EAAA,OAEA,OAAA9B,eAISP,YAAAW,EAAA,4BAEAsB,mBA3FX,IAAA,IAAAb,KAAAO,EAAA,CACE,IAAAW,EAAAX,EAAAP,GACAI,GAAAX,EAAAO,UAEAkB,IAAWd,GAAAX,EAAAyB,WAIb,OAAAd,GAmFWe,GAAAC,MAGNf,KAAAY,EAAAA,wBAKH,OAAA9B,kEA+BI,OAvBAkC,EAAAC,eAAAD,EAAAE,YAAAC,KAAAH,wCAII,IAAArB,IAAAA,GAAAyB,KAAA/C,kCAEE2C,EAAAK,OAAA1B,OACK,gBAELE,EAAAyB,EAAAxB,OACAwB,EAAAC,KAAA,IACAxD,EAAAI,UAAA,KACE,IAAAE,EAAA,GAAAN,EAAAM,oCAGAiD,EAAAzB,GAAAxB,GAIJ+C,KAAA/C,OAAAmD,aAIJlD,EAAAC,MAEDyB,MAAA,IAAAR,EAAA8B,EAAAG,KAAA,OAAA,IAAAvB,KAMLwB,SAAAC,GACEhD,IACEiD,OAAAC,oBAAA,SAAAlD,qDAOEgD"}