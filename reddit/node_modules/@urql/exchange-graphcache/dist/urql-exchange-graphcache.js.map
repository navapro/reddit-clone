{"version":3,"file":"urql-exchange-graphcache.js","sources":["../src/ast/node.ts","../src/ast/variables.ts","../src/helpers/help.ts","../src/ast/traversal.ts","../src/ast/schema.ts","../src/ast/schemaPredicates.ts","../src/store/keys.ts","../src/helpers/dict.ts","../src/store/data.ts","../src/operations/shared.ts","../src/operations/write.ts","../src/operations/invalidate.ts","../src/store/store.ts","../src/operations/query.ts","../src/helpers/operation.ts","../src/cacheExchange.ts","../src/offlineExchange.ts"],"sourcesContent":["import {\n  NamedTypeNode,\n  NameNode,\n  SelectionNode,\n  SelectionSetNode,\n  InlineFragmentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  Kind,\n} from 'graphql';\n\nexport type SelectionSet = ReadonlyArray<SelectionNode>;\n\n/** Returns the name of a given node */\nexport const getName = (node: { name: NameNode }): string => node.name.value;\n\nexport const getFragmentTypeName = (node: FragmentDefinitionNode): string =>\n  node.typeCondition.name.value;\n\n/** Returns either the field's name or the field's alias */\nexport const getFieldAlias = (node: FieldNode): string =>\n  node.alias ? node.alias.value : node.name.value;\n\nconst emptySelectionSet: SelectionSet = [];\n\n/** Returns the SelectionSet for a given inline or defined fragment node */\nexport const getSelectionSet = (node: {\n  selectionSet?: SelectionSetNode;\n}): SelectionSet =>\n  node.selectionSet ? node.selectionSet.selections : emptySelectionSet;\n\nexport const getTypeCondition = (node: {\n  typeCondition?: NamedTypeNode;\n}): string | null =>\n  node.typeCondition ? node.typeCondition.name.value : null;\n\nexport const isFieldNode = (node: SelectionNode): node is FieldNode =>\n  node.kind === Kind.FIELD;\n\nexport const isInlineFragment = (\n  node: SelectionNode\n): node is InlineFragmentNode => node.kind === Kind.INLINE_FRAGMENT;\n","import {\n  FieldNode,\n  OperationDefinitionNode,\n  valueFromASTUntyped,\n} from 'graphql';\n\nimport { getName } from './node';\n\nimport { Variables } from '../types';\n\n/** Evaluates a fields arguments taking vars into account */\nexport const getFieldArguments = (\n  node: FieldNode,\n  vars: Variables\n): null | Variables => {\n  let args: null | Variables = null;\n  if (node.arguments) {\n    for (let i = 0, l = node.arguments.length; i < l; i++) {\n      const arg = node.arguments[i];\n      const value = valueFromASTUntyped(arg.value, vars);\n      if (value !== undefined && value !== null) {\n        if (!args) args = {};\n        args[getName(arg)] = value as any;\n      }\n    }\n  }\n  return args;\n};\n\n/** Returns a filtered form of variables with values missing that the query doesn't require */\nexport const filterVariables = (\n  node: OperationDefinitionNode,\n  input: void | object\n) => {\n  if (!input || !node.variableDefinitions) {\n    return undefined;\n  }\n\n  const vars = {};\n  for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n    const name = getName(node.variableDefinitions[i].variable);\n    vars[name] = input[name];\n  }\n\n  return vars;\n};\n\n/** Returns a normalized form of variables with defaulted values */\nexport const normalizeVariables = (\n  node: OperationDefinitionNode,\n  input: void | Record<string, unknown>\n): Variables => {\n  const vars = {};\n  if (!input) return vars;\n\n  if (node.variableDefinitions) {\n    for (let i = 0, l = node.variableDefinitions.length; i < l; i++) {\n      const def = node.variableDefinitions[i];\n      const name = getName(def.variable);\n      vars[name] =\n        input[name] === undefined && def.defaultValue\n          ? valueFromASTUntyped(def.defaultValue, input)\n          : input[name];\n    }\n  }\n\n  for (const key in input) {\n    if (!(key in vars)) vars[key] = input[key];\n  }\n\n  return vars;\n};\n","// These are guards that are used throughout the codebase to warn or error on\n// unexpected behaviour or conditions.\n// Every warning and error comes with a number that uniquely identifies them.\n// You can read more about the messages themselves in `docs/graphcache/errors.md`\n\nimport { Kind, ExecutableDefinitionNode, InlineFragmentNode } from 'graphql';\n\nexport type ErrorCode =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24\n  | 25\n  | 26;\n\ntype DebugNode = ExecutableDefinitionNode | InlineFragmentNode;\n\n// URL unfurls to https://formidable.com/open-source/urql/docs/graphcache/errors/\nconst helpUrl = '\\nhttps://bit.ly/2XbVrpR#';\nconst cache = new Set<string>();\n\nexport const currentDebugStack: string[] = [];\n\nexport const popDebugNode = () => currentDebugStack.pop();\n\nexport const pushDebugNode = (typename: void | string, node: DebugNode) => {\n  let identifier = '';\n  if (node.kind === Kind.INLINE_FRAGMENT) {\n    identifier = typename\n      ? `Inline Fragment on \"${typename}\"`\n      : 'Inline Fragment';\n  } else if (node.kind === Kind.OPERATION_DEFINITION) {\n    const name = node.name ? `\"${node.name.value}\"` : 'Unnamed';\n    identifier = `${name} ${node.operation}`;\n  } else if (node.kind === Kind.FRAGMENT_DEFINITION) {\n    identifier = `\"${node.name.value}\" Fragment`;\n  }\n\n  if (identifier) {\n    currentDebugStack.push(identifier);\n  }\n};\n\nconst getDebugOutput = (): string =>\n  currentDebugStack.length\n    ? '\\n(Caused At: ' + currentDebugStack.join(', ') + ')'\n    : '';\n\nexport function invariant(\n  condition: any,\n  message: string,\n  code: ErrorCode\n): asserts condition {\n  if (!condition) {\n    let errorMessage = message || 'Minfied Error #' + code + '\\n';\n    if (process.env.NODE_ENV !== 'production') {\n      errorMessage += getDebugOutput();\n    }\n\n    const error = new Error(errorMessage + helpUrl + code);\n    error.name = 'Graphcache Error';\n    throw error;\n  }\n}\n\nexport function warn(message: string, code: ErrorCode) {\n  if (!cache.has(message)) {\n    console.warn(message + getDebugOutput() + helpUrl + code);\n    cache.add(message);\n  }\n}\n","import {\n  SelectionNode,\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  valueFromASTUntyped,\n  Kind,\n} from 'graphql';\n\nimport { getName } from './node';\n\nimport { invariant } from '../helpers/help';\nimport { Fragments, Variables } from '../types';\n\n/** Returns the main operation's definition */\nexport const getMainOperation = (\n  doc: DocumentNode\n): OperationDefinitionNode => {\n  for (let i = 0; i < doc.definitions.length; i++) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      return doc.definitions[i] as OperationDefinitionNode;\n    }\n  }\n\n  invariant(\n    false,\n    'Invalid GraphQL document: All GraphQL documents must contain an OperationDefinition' +\n      'node for a query, subscription, or mutation.',\n    1\n  );\n};\n\n/** Returns a mapping from fragment names to their selections */\nexport const getFragments = (doc: DocumentNode): Fragments => {\n  const fragments: Fragments = {};\n  for (let i = 0; i < doc.definitions.length; i++) {\n    const node = doc.definitions[i];\n    if (node.kind === Kind.FRAGMENT_DEFINITION) {\n      fragments[getName(node)] = node;\n    }\n  }\n\n  return fragments;\n};\n\n/** Resolves @include and @skip directives to determine whether field is included. */\nexport const shouldInclude = (\n  node: SelectionNode,\n  vars: Variables\n): boolean => {\n  // Finds any @include or @skip directive that forces the node to be skipped\n  for (let i = 0; node.directives && i < node.directives.length; i++) {\n    const directive = node.directives[i];\n    const name = getName(directive);\n    if (\n      (name === 'include' || name === 'skip') &&\n      directive.arguments &&\n      directive.arguments[0] &&\n      getName(directive.arguments[0]) === 'if'\n    ) {\n      // Return whether this directive forces us to skip\n      // `@include(if: false)` or `@skip(if: true)`\n      const value = valueFromASTUntyped(directive.arguments[0].value, vars);\n      return name === 'include' ? !!value : !value;\n    }\n  }\n\n  return true;\n};\n\n/** Resolves @defer directive to determine whether a fragment is potentially skipped. */\nexport const isDeferred = (\n  node: FragmentSpreadNode | InlineFragmentNode,\n  vars: Variables\n): boolean => {\n  for (let i = 0; node.directives && i < node.directives.length; i++) {\n    const directive = node.directives[i];\n    const name = getName(directive);\n    if (name === 'defer') {\n      for (\n        let j = 0;\n        directive.arguments && j < directive.arguments.length;\n        j++\n      ) {\n        const argument = directive.arguments[i];\n        if (getName(argument) === 'if') {\n          // Return whether `@defer(if: )` is enabled\n          return !!valueFromASTUntyped(argument.value, vars);\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n","import {\n  IntrospectionQuery,\n  IntrospectionSchema,\n  IntrospectionInputValue,\n  IntrospectionTypeRef,\n  IntrospectionType,\n} from 'graphql';\n\nexport interface SchemaField {\n  name: string;\n  type: IntrospectionTypeRef;\n  args(): Record<string, IntrospectionInputValue | void>;\n}\n\nexport interface SchemaObject {\n  name: string;\n  kind: 'INTERFACE' | 'OBJECT';\n  interfaces(): Record<string, unknown>;\n  fields(): Record<string, SchemaField | void>;\n}\n\nexport interface SchemaUnion {\n  name: string;\n  kind: 'UNION';\n  types(): Record<string, unknown>;\n}\n\nexport interface SchemaIntrospector {\n  query: string | null;\n  mutation: string | null;\n  subscription: string | null;\n  types?: Map<string, SchemaObject | SchemaUnion>;\n  isSubType(abstract: string, possible: string): boolean;\n}\n\nexport interface PartialIntrospectionSchema {\n  queryType: { name: string; kind?: any };\n  mutationType?: { name: string; kind?: any } | null;\n  subscriptionType?: { name: string; kind?: any } | null;\n  types?: IntrospectionSchema['types'];\n}\n\nexport type IntrospectionData =\n  | IntrospectionQuery\n  | { __schema: PartialIntrospectionSchema };\n\nexport const buildClientSchema = ({\n  __schema,\n}: IntrospectionData): SchemaIntrospector => {\n  const typemap: Map<string, SchemaObject | SchemaUnion> = new Map();\n\n  const buildNameMap = <T extends { name: string }>(\n    arr: ReadonlyArray<T>\n  ): (() => { [name: string]: T }) => {\n    let map: Record<string, T> | void;\n    return () => {\n      if (!map) {\n        map = {};\n        for (let i = 0; i < arr.length; i++) map[arr[i].name] = arr[i];\n      }\n      return map;\n    };\n  };\n\n  const buildType = (\n    type: IntrospectionType\n  ): SchemaObject | SchemaUnion | void => {\n    switch (type.kind) {\n      case 'OBJECT':\n      case 'INTERFACE':\n        return {\n          name: type.name,\n          kind: type.kind as 'OBJECT' | 'INTERFACE',\n          interfaces: buildNameMap(type.interfaces || []),\n          fields: buildNameMap(\n            type.fields.map(field => ({\n              name: field.name,\n              type: field.type,\n              args: buildNameMap(field.args),\n            }))\n          ),\n        } as SchemaObject;\n      case 'UNION':\n        return {\n          name: type.name,\n          kind: type.kind as 'UNION',\n          types: buildNameMap(type.possibleTypes || []),\n        } as SchemaUnion;\n    }\n  };\n\n  const schema: SchemaIntrospector = {\n    query: __schema.queryType ? __schema.queryType.name : null,\n    mutation: __schema.mutationType ? __schema.mutationType.name : null,\n    subscription: __schema.subscriptionType\n      ? __schema.subscriptionType.name\n      : null,\n    types: undefined,\n    isSubType(abstract: string, possible: string) {\n      const abstractType = typemap.get(abstract);\n      const possibleType = typemap.get(possible);\n      if (!abstractType || !possibleType) {\n        return false;\n      } else if (abstractType.kind === 'UNION') {\n        return !!abstractType.types()[possible];\n      } else if (\n        abstractType.kind !== 'OBJECT' &&\n        possibleType.kind === 'OBJECT'\n      ) {\n        return !!possibleType.interfaces()[abstract];\n      } else {\n        return abstract === possible;\n      }\n    },\n  };\n\n  if (__schema.types) {\n    schema.types = typemap;\n    for (let i = 0; i < __schema.types.length; i++) {\n      const type = __schema.types[i];\n      if (type && type.name) {\n        const out = buildType(type);\n        if (out) typemap.set(type.name, out);\n      }\n    }\n  }\n\n  return schema;\n};\n","import { InlineFragmentNode, FragmentDefinitionNode } from 'graphql';\n\nimport { warn, invariant } from '../helpers/help';\nimport { getTypeCondition } from './node';\nimport { SchemaIntrospector, SchemaObject } from './schema';\n\nimport {\n  KeyingConfig,\n  UpdateResolver,\n  ResolverConfig,\n  OptimisticMutationConfig,\n} from '../types';\n\nconst BUILTIN_NAME = '__';\n\nexport const isFieldNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string\n): boolean => {\n  const field = getField(schema, typename, fieldName);\n  return !!field && field.type.kind !== 'NON_NULL';\n};\n\nexport const isListNullable = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string\n): boolean => {\n  const field = getField(schema, typename, fieldName);\n  if (!field) return false;\n  const ofType =\n    field.type.kind === 'NON_NULL' ? field.type.ofType : field.type;\n  return ofType.kind === 'LIST' && ofType.ofType.kind !== 'NON_NULL';\n};\n\nexport const isFieldAvailableOnType = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string\n): boolean =>\n  fieldName.indexOf(BUILTIN_NAME) === 0 ||\n  typename.indexOf(BUILTIN_NAME) === 0 ||\n  !!getField(schema, typename, fieldName);\n\nexport const isInterfaceOfType = (\n  schema: SchemaIntrospector,\n  node: InlineFragmentNode | FragmentDefinitionNode,\n  typename: string | void\n): boolean => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) {\n    return true;\n  } else if (\n    schema.types!.has(typeCondition) &&\n    schema.types!.get(typeCondition)!.kind === 'OBJECT'\n  ) {\n    return typeCondition === typename;\n  }\n\n  expectAbstractType(schema, typeCondition!);\n  expectObjectType(schema, typename!);\n  return schema.isSubType(typeCondition, typename);\n};\n\nconst getField = (\n  schema: SchemaIntrospector,\n  typename: string,\n  fieldName: string\n) => {\n  if (\n    fieldName.indexOf(BUILTIN_NAME) === 0 ||\n    typename.indexOf(BUILTIN_NAME) === 0\n  )\n    return;\n\n  expectObjectType(schema, typename);\n  const object = schema.types!.get(typename) as SchemaObject;\n  const field = object.fields()[fieldName];\n  if (!field) {\n    warn(\n      'Invalid field: The field `' +\n        fieldName +\n        '` does not exist on `' +\n        typename +\n        '`, ' +\n        'but the GraphQL document expects it to exist.\\n' +\n        'Traversal will continue, however this may lead to undefined behavior!',\n      4\n    );\n  }\n\n  return field;\n};\n\nfunction expectObjectType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      schema.types!.get(typename)!.kind === 'OBJECT',\n    'Invalid Object type: The type `' +\n      typename +\n      '` is not an object in the defined schema, ' +\n      'but the GraphQL document is traversing it.',\n    3\n  );\n}\n\nfunction expectAbstractType(schema: SchemaIntrospector, typename: string) {\n  invariant(\n    schema.types!.has(typename) &&\n      (schema.types!.get(typename)!.kind === 'INTERFACE' ||\n        schema.types!.get(typename)!.kind === 'UNION'),\n    'Invalid Abstract type: The type `' +\n      typename +\n      '` is not an Interface or Union type in the defined schema, ' +\n      'but a fragment in the GraphQL document is using it as a type condition.',\n    5\n  );\n}\n\nexport function expectValidKeyingConfig(\n  schema: SchemaIntrospector,\n  keys: KeyingConfig\n): void {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const key in keys) {\n      if (!schema.types!.has(key)) {\n        warn(\n          'Invalid Object type: The type `' +\n            key +\n            '` is not an object in the defined schema, but the `keys` option is referencing it.',\n          20\n        );\n      }\n    }\n  }\n}\n\nexport function expectValidUpdatesConfig(\n  schema: SchemaIntrospector,\n  updates: Record<string, Record<string, UpdateResolver | undefined>>\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  if (schema.mutation) {\n    const mutationFields = (schema.types!.get(\n      schema.mutation\n    ) as SchemaObject).fields();\n    const givenMutations = updates[schema.mutation] || {};\n    for (const fieldName in givenMutations) {\n      if (mutationFields[fieldName] === undefined) {\n        warn(\n          'Invalid mutation field: `' +\n            fieldName +\n            '` is not in the defined schema, but the `updates.Mutation` option is referencing it.',\n          21\n        );\n      }\n    }\n  }\n\n  if (schema.subscription) {\n    const subscriptionFields = (schema.types!.get(\n      schema.subscription\n    ) as SchemaObject).fields();\n    const givenSubscription = updates[schema.subscription] || {};\n    for (const fieldName in givenSubscription) {\n      if (subscriptionFields[fieldName] === undefined) {\n        warn(\n          'Invalid subscription field: `' +\n            fieldName +\n            '` is not in the defined schema, but the `updates.Subscription` option is referencing it.',\n          22\n        );\n      }\n    }\n  }\n}\n\nfunction warnAboutResolver(name: string): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` is not in the defined schema, but the \\`resolvers\\` option is referencing it.`,\n    23\n  );\n}\n\nfunction warnAboutAbstractResolver(\n  name: string,\n  kind: 'UNION' | 'INTERFACE'\n): void {\n  warn(\n    `Invalid resolver: \\`${name}\\` does not match to a concrete type in the schema, but the \\`resolvers\\` option is referencing it. Implement the resolver for the types that ${\n      kind === 'UNION' ? 'make up the union' : 'implement the interface'\n    } instead.`,\n    26\n  );\n}\n\nexport function expectValidResolversConfig(\n  schema: SchemaIntrospector,\n  resolvers: ResolverConfig\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  for (const key in resolvers) {\n    if (key === 'Query') {\n      if (schema.query) {\n        const validQueries = (schema.types!.get(\n          schema.query\n        ) as SchemaObject).fields();\n        for (const resolverQuery in resolvers.Query) {\n          if (!validQueries[resolverQuery]) {\n            warnAboutResolver('Query.' + resolverQuery);\n          }\n        }\n      } else {\n        warnAboutResolver('Query');\n      }\n    } else {\n      if (!schema.types!.has(key)) {\n        warnAboutResolver(key);\n      } else if (\n        schema.types!.get(key)!.kind === 'INTERFACE' ||\n        schema.types!.get(key)!.kind === 'UNION'\n      ) {\n        warnAboutAbstractResolver(\n          key,\n          schema.types!.get(key)!.kind as 'INTERFACE' | 'UNION'\n        );\n      } else {\n        const validTypeProperties = (schema.types!.get(\n          key\n        ) as SchemaObject).fields();\n        for (const resolverProperty in resolvers[key]) {\n          if (!validTypeProperties[resolverProperty]) {\n            warnAboutResolver(key + '.' + resolverProperty);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function expectValidOptimisticMutationsConfig(\n  schema: SchemaIntrospector,\n  optimisticMutations: OptimisticMutationConfig\n): void {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  if (schema.mutation) {\n    const validMutations = (schema.types!.get(\n      schema.mutation\n    ) as SchemaObject).fields();\n    for (const mutation in optimisticMutations) {\n      if (!validMutations[mutation]) {\n        warn(\n          `Invalid optimistic mutation field: \\`${mutation}\\` is not a mutation field in the defined schema, but the \\`optimistic\\` option is referencing it.`,\n          24\n        );\n      }\n    }\n  }\n}\n","import { stringifyVariables } from '@urql/core';\nimport { FieldArgs, FieldInfo, KeyInfo } from '../types';\n\nexport const keyOfField = (fieldName: string, args?: FieldArgs) =>\n  args ? `${fieldName}(${stringifyVariables(args)})` : fieldName;\n\nexport const joinKeys = (parentKey: string, key: string) =>\n  `${parentKey}.${key}`;\n\nexport const fieldInfoOfKey = (fieldKey: string): FieldInfo => {\n  const parenIndex = fieldKey.indexOf('(');\n  if (parenIndex > -1) {\n    return {\n      fieldKey,\n      fieldName: fieldKey.slice(0, parenIndex),\n      arguments: JSON.parse(fieldKey.slice(parenIndex + 1, -1)),\n    };\n  } else {\n    return {\n      fieldKey,\n      fieldName: fieldKey,\n      arguments: null,\n    };\n  }\n};\n\nexport const serializeKeys = (entityKey: string, fieldKey: string) =>\n  `${entityKey.replace(/\\./g, '%2e')}.${fieldKey}`;\n\nexport const deserializeKeyInfo = (key: string): KeyInfo => {\n  const dotIndex = key.indexOf('.');\n  const entityKey = key.slice(0, dotIndex).replace(/%2e/g, '.');\n  const fieldKey = key.slice(dotIndex + 1);\n  return { entityKey, fieldKey };\n};\n","export const makeDict = (): any => Object.create(null);\n\nexport const isDictEmpty = (x: any) => {\n  for (const _ in x) return false;\n  return true;\n};\n","import { stringifyVariables } from '@urql/core';\n\nimport {\n  Link,\n  EntityField,\n  FieldInfo,\n  StorageAdapter,\n  SerializedEntries,\n  Dependencies,\n  OperationType,\n  Data,\n} from '../types';\n\nimport {\n  serializeKeys,\n  deserializeKeyInfo,\n  fieldInfoOfKey,\n  joinKeys,\n} from './keys';\n\nimport { makeDict } from '../helpers/dict';\nimport { invariant, currentDebugStack } from '../helpers/help';\n\ntype Dict<T> = Record<string, T>;\ntype KeyMap<T> = Map<string, T>;\ntype OperationMap<T> = Map<number, T>;\n\ninterface NodeMap<T> {\n  optimistic: OperationMap<KeyMap<Dict<T | undefined>>>;\n  base: KeyMap<Dict<T>>;\n}\n\nexport interface InMemoryData {\n  /** Flag for whether deferred tasks have been scheduled yet */\n  defer: boolean;\n  /** A list of entities that have been flagged for gargabe collection since no references to them are left */\n  gc: Set<string>;\n  /** A list of entity+field keys that will be persisted */\n  persist: Set<string>;\n  /** The API's \"Query\" typename which is needed to filter dependencies */\n  queryRootKey: string;\n  /** Number of references to each entity (except \"Query\") */\n  refCount: KeyMap<number>;\n  /** Number of references to each entity on optimistic layers */\n  refLock: OperationMap<KeyMap<number>>;\n  /** A map of entity fields (key-value entries per entity) */\n  records: NodeMap<EntityField>;\n  /** A map of entity links which are connections from one entity to another (key-value entries per entity) */\n  links: NodeMap<Link>;\n  /** A set of Query operation keys that are in-flight and deferred/streamed */\n  deferredKeys: Set<number>;\n  /** A set of Query operation keys that are in-flight and awaiting a result */\n  commutativeKeys: Set<number>;\n  /** The order of optimistic layers */\n  optimisticOrder: number[];\n  /** This may be a persistence adapter that will receive changes in a batch */\n  storage: StorageAdapter | null;\n}\n\nlet currentOwnership: null | WeakSet<Data> = null;\nlet currentDataMapping: null | WeakMap<Data, Data> = null;\nlet currentOperation: null | OperationType = null;\nlet currentData: null | InMemoryData = null;\nlet currentDependencies: null | Dependencies = null;\nlet currentOptimisticKey: null | number = null;\nlet currentOptimistic = false;\n\n/** Creates a new data object unless it's been created in this data run */\nexport const makeData = (data?: Data): Data => {\n  let newData: Data;\n  if (data) {\n    if (currentOwnership!.has(data)) return data;\n    newData = currentDataMapping!.get(data) || ({ ...data } as Data);\n    currentDataMapping!.set(data, newData);\n  } else {\n    newData = {} as Data;\n  }\n\n  currentOwnership!.add(newData);\n  return newData;\n};\n\nexport const isWriting = (): boolean => currentOperation === 'write';\n\nexport const ownsData = (data?: Data): boolean =>\n  !!data && currentOwnership!.has(data);\n\n/** Before reading or writing the global state needs to be initialised */\nexport const initDataState = (\n  operationType: OperationType,\n  data: InMemoryData,\n  layerKey?: number | null,\n  isOptimistic?: boolean\n) => {\n  currentOwnership = new WeakSet();\n  currentDataMapping = new WeakMap();\n  currentOperation = operationType;\n  currentData = data;\n  currentDependencies = new Set();\n  currentOptimistic = !!isOptimistic;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  if (!layerKey) {\n    currentOptimisticKey = null;\n  } else if (currentOperation === 'read') {\n    // We don't create new layers for read operations and instead simply\n    // apply the currently available layer, if any\n    currentOptimisticKey = layerKey;\n  } else if (isOptimistic || data.optimisticOrder.length > 1) {\n    // If this operation isn't optimistic and we see it for the first time,\n    // then it must've been optimistic in the past, so we can proactively\n    // clear the optimistic data before writing\n    if (!isOptimistic && !data.commutativeKeys.has(layerKey)) {\n      reserveLayer(data, layerKey);\n    } else if (isOptimistic) {\n      if (\n        data.optimisticOrder.indexOf(layerKey) !== -1 &&\n        !data.commutativeKeys.has(layerKey)\n      ) {\n        data.optimisticOrder.splice(data.optimisticOrder.indexOf(layerKey), 1);\n      }\n      // NOTE: This optimally shouldn't happen as it implies that an optimistic\n      // write is being performed after a concrete write.\n      data.commutativeKeys.delete(layerKey);\n    }\n\n    // An optimistic update of a mutation may force an optimistic layer,\n    // or this Query update may be applied optimistically since it's part\n    // of a commutative chain\n    currentOptimisticKey = layerKey;\n    createLayer(data, layerKey);\n  } else {\n    // Otherwise we don't create an optimistic layer and clear the\n    // operation's one if it already exists\n    // We also do this when only one layer exists to avoid having to squash\n    // any layers at the end of writing this layer\n    currentOptimisticKey = null;\n    deleteLayer(data, layerKey);\n  }\n};\n\n/** Reset the data state after read/write is complete */\nexport const clearDataState = () => {\n  // NOTE: This is only called to check for the invariant to pass\n  if (process.env.NODE_ENV !== 'production') {\n    getCurrentDependencies();\n  }\n\n  const data = currentData!;\n  const layerKey = currentOptimisticKey;\n  currentOptimistic = false;\n  currentOptimisticKey = null;\n\n  // Determine whether the current operation has been a commutative layer\n  if (layerKey && data.optimisticOrder.indexOf(layerKey) > -1) {\n    // Squash all layers in reverse order (low priority upwards) that have\n    // been written already\n    let i = data.optimisticOrder.length;\n    while (\n      --i >= 0 &&\n      data.refLock.has(data.optimisticOrder[i]) &&\n      data.commutativeKeys.has(data.optimisticOrder[i]) &&\n      !data.deferredKeys.has(data.optimisticOrder[i])\n    ) {\n      squashLayer(data.optimisticOrder[i]);\n    }\n  }\n\n  currentOwnership = null;\n  currentDataMapping = null;\n  currentOperation = null;\n  currentData = null;\n  currentDependencies = null;\n  if (process.env.NODE_ENV !== 'production') {\n    currentDebugStack.length = 0;\n  }\n\n  // Schedule deferred tasks if we haven't already\n  if (process.env.NODE_ENV !== 'test' && !data.defer) {\n    data.defer = true;\n    setTimeout(() => {\n      initDataState('read', data, null);\n      gc();\n      persistData();\n      clearDataState();\n      data.defer = false;\n    });\n  }\n};\n\n/** Initialises then resets the data state, which may squash this layer if necessary */\nexport const noopDataState = (\n  data: InMemoryData,\n  layerKey: number | null,\n  isOptimistic?: boolean\n) => {\n  if (layerKey && !isOptimistic) data.deferredKeys.delete(layerKey);\n  initDataState('write', data, layerKey, isOptimistic);\n  clearDataState();\n};\n\nexport const getCurrentOperation = (): OperationType => {\n  invariant(\n    currentOperation !== null,\n    'Invalid Cache call: The cache may only be accessed or mutated during' +\n      'operations like write or query, or as part of its resolvers, updaters, ' +\n      'or optimistic configs.',\n    2\n  );\n\n  return currentOperation;\n};\n\n/** As we're writing, we keep around all the records and links we've read or have written to */\nexport const getCurrentDependencies = (): Dependencies => {\n  invariant(\n    currentDependencies !== null,\n    'Invalid Cache call: The cache may only be accessed or mutated during' +\n      'operations like write or query, or as part of its resolvers, updaters, ' +\n      'or optimistic configs.',\n    2\n  );\n\n  return currentDependencies;\n};\n\nexport const make = (queryRootKey: string): InMemoryData => ({\n  defer: false,\n  gc: new Set(),\n  persist: new Set(),\n  queryRootKey,\n  refCount: new Map(),\n  refLock: new Map(),\n  links: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  records: {\n    optimistic: new Map(),\n    base: new Map(),\n  },\n  deferredKeys: new Set(),\n  commutativeKeys: new Set(),\n  optimisticOrder: [],\n  storage: null,\n});\n\n/** Adds a node value to a NodeMap (taking optimistic values into account */\nconst setNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string,\n  value: T\n) => {\n  // Optimistic values are written to a map in the optimistic dict\n  // All other values are written to the base map\n  const keymap: KeyMap<Dict<T | undefined>> = currentOptimisticKey\n    ? map.optimistic.get(currentOptimisticKey)!\n    : map.base;\n\n  // On the map itself we get or create the entity as a dict\n  let entity = keymap.get(entityKey) as Dict<T | undefined>;\n  if (entity === undefined) {\n    keymap.set(entityKey, (entity = makeDict()));\n  }\n\n  // If we're setting undefined we delete the node's entry\n  // On optimistic layers we actually set undefined so it can\n  // override the base value\n  if (value === undefined && !currentOptimisticKey) {\n    delete entity[fieldKey];\n  } else {\n    entity[fieldKey] = value;\n  }\n};\n\n/** Gets a node value from a NodeMap (taking optimistic values into account */\nconst getNode = <T>(\n  map: NodeMap<T>,\n  entityKey: string,\n  fieldKey: string\n): T | undefined => {\n  let node: Dict<T | undefined> | undefined;\n  // A read may be initialised to skip layers until its own, which is useful for\n  // reading back written data. It won't skip over optimistic layers however\n  let skip =\n    !currentOptimistic &&\n    currentOperation === 'read' &&\n    currentOptimisticKey &&\n    currentData!.commutativeKeys.has(currentOptimisticKey);\n  // This first iterates over optimistic layers (in order)\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const layerKey = currentData!.optimisticOrder[i];\n    const optimistic = map.optimistic.get(layerKey);\n    // If we're reading starting from a specific layer, we skip until a match\n    skip = skip && layerKey !== currentOptimisticKey;\n    // If the node and node value exists it is returned, including undefined\n    if (\n      optimistic &&\n      (!skip || !currentData!.commutativeKeys.has(layerKey)) &&\n      (!currentOptimistic ||\n        currentOperation === 'write' ||\n        currentData!.commutativeKeys.has(layerKey)) &&\n      (node = optimistic.get(entityKey)) !== undefined &&\n      fieldKey in node\n    ) {\n      return node[fieldKey];\n    }\n  }\n\n  // Otherwise we read the non-optimistic base value\n  node = map.base.get(entityKey);\n  return node !== undefined ? node[fieldKey] : undefined;\n};\n\n/** Adjusts the reference count of an entity on a refCount dict by \"by\" and updates the gc */\nconst updateRCForEntity = (\n  gc: undefined | Set<string>,\n  refCount: KeyMap<number>,\n  entityKey: string,\n  by: number\n): void => {\n  // Retrieve the reference count and adjust it by \"by\"\n  const count = refCount.get(entityKey) || 0;\n  const newCount = count + by;\n  refCount.set(entityKey, newCount);\n  // Add it to the garbage collection batch if it needs to be deleted or remove it\n  // from the batch if it needs to be kept\n  if (gc) {\n    if (newCount <= 0) gc.add(entityKey);\n    else if (count <= 0 && newCount > 0) gc.delete(entityKey);\n  }\n};\n\n/** Adjusts the reference counts of all entities of a link on a refCount dict by \"by\" and updates the gc */\nconst updateRCForLink = (\n  gc: undefined | Set<string>,\n  refCount: KeyMap<number>,\n  link: Link | undefined,\n  by: number\n): void => {\n  if (typeof link === 'string') {\n    updateRCForEntity(gc, refCount, link, by);\n  } else if (Array.isArray(link)) {\n    for (let i = 0, l = link.length; i < l; i++) {\n      if (Array.isArray(link[i])) {\n        updateRCForLink(gc, refCount, link[i], by);\n      } else if (link[i]) {\n        updateRCForEntity(gc, refCount, link[i] as string, by);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of a given node dict to a given array if it hasn't been seen */\nconst extractNodeFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  node: Dict<T> | undefined\n): void => {\n  if (node !== undefined) {\n    for (const fieldKey in node) {\n      if (!seenFieldKeys.has(fieldKey)) {\n        // If the node hasn't been seen the serialized fieldKey is turnt back into\n        // a rich FieldInfo object that also contains the field's name and arguments\n        fieldInfos.push(fieldInfoOfKey(fieldKey));\n        seenFieldKeys.add(fieldKey);\n      }\n    }\n  }\n};\n\n/** Writes all parsed FieldInfo objects of all nodes in a NodeMap to a given array */\nconst extractNodeMapFields = <T>(\n  fieldInfos: FieldInfo[],\n  seenFieldKeys: Set<string>,\n  entityKey: string,\n  map: NodeMap<T>\n) => {\n  // Extracts FieldInfo for the entity in the base map\n  extractNodeFields(fieldInfos, seenFieldKeys, map.base.get(entityKey));\n\n  // Then extracts FieldInfo for the entity from the optimistic maps\n  for (let i = 0, l = currentData!.optimisticOrder.length; i < l; i++) {\n    const optimistic = map.optimistic.get(currentData!.optimisticOrder[i]);\n    if (optimistic !== undefined) {\n      extractNodeFields(fieldInfos, seenFieldKeys, optimistic.get(entityKey));\n    }\n  }\n};\n\n/** Garbage collects all entities that have been marked as having no references */\nexport const gc = () => {\n  // Iterate over all entities that have been marked for deletion\n  // Entities have been marked for deletion in `updateRCForEntity` if\n  // their reference count dropped to 0\n  const { gc: batch } = currentData!;\n  for (const entityKey of batch.keys()) {\n    // Check first whether the reference count is still 0\n    const rc = currentData!.refCount.get(entityKey) || 0;\n    if (rc > 0) {\n      batch.delete(entityKey);\n      return;\n    }\n\n    // Each optimistic layer may also still contain some references to marked entities\n    for (const layerKey of currentData!.refLock.keys()) {\n      const refCount = currentData!.refLock.get(layerKey);\n      if (refCount) {\n        const locks = refCount.get(entityKey) || 0;\n        // If the optimistic layer has any references to the entity, don't GC it,\n        // otherwise delete the reference count from the optimistic layer\n        if (locks > 0) return;\n        refCount.delete(entityKey);\n      }\n    }\n\n    // Delete the reference count, and delete the entity from the GC batch\n    currentData!.refCount.delete(entityKey);\n    batch.delete(entityKey);\n    currentData!.records.base.delete(entityKey);\n    const linkNode = currentData!.links.base.get(entityKey);\n    if (linkNode) {\n      currentData!.links.base.delete(entityKey);\n      for (const fieldKey in linkNode) {\n        updateRCForLink(batch, currentData!.refCount, linkNode[fieldKey], -1);\n      }\n    }\n  }\n};\n\nconst updateDependencies = (entityKey: string, fieldKey?: string) => {\n  if (fieldKey !== '__typename') {\n    if (entityKey !== currentData!.queryRootKey) {\n      currentDependencies!.add(entityKey);\n    } else if (fieldKey !== undefined) {\n      currentDependencies!.add(joinKeys(entityKey, fieldKey));\n    }\n  }\n};\n\nconst updatePersist = (entityKey: string, fieldKey: string) => {\n  if (!currentOptimistic && currentData!.storage) {\n    currentData!.persist.add(serializeKeys(entityKey, fieldKey));\n  }\n};\n\n/** Reads an entity's field (a \"record\") from data */\nexport const readRecord = (\n  entityKey: string,\n  fieldKey: string\n): EntityField => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.records, entityKey, fieldKey);\n};\n\n/** Reads an entity's link from data */\nexport const readLink = (\n  entityKey: string,\n  fieldKey: string\n): Link | undefined => {\n  updateDependencies(entityKey, fieldKey);\n  return getNode(currentData!.links, entityKey, fieldKey);\n};\n\n/** Writes an entity's field (a \"record\") to data */\nexport const writeRecord = (\n  entityKey: string,\n  fieldKey: string,\n  value?: EntityField\n) => {\n  updateDependencies(entityKey, fieldKey);\n  updatePersist(entityKey, fieldKey);\n  setNode(currentData!.records, entityKey, fieldKey, value);\n};\n\nexport const hasField = (entityKey: string, fieldKey: string): boolean =>\n  readRecord(entityKey, fieldKey) !== undefined ||\n  readLink(entityKey, fieldKey) !== undefined;\n\n/** Writes an entity's link to data */\nexport const writeLink = (\n  entityKey: string,\n  fieldKey: string,\n  link?: Link | undefined\n) => {\n  const data = currentData!;\n  // Retrieve the reference counting dict or the optimistic reference locking dict\n  let refCount: KeyMap<number> | undefined;\n  // Retrive the link NodeMap from either an optimistic or the base layer\n  let links: KeyMap<Dict<Link | undefined>> | undefined;\n  // Set the GC batch if we're not optimistically updating\n  let gc: undefined | Set<string>;\n  if (currentOptimisticKey) {\n    // The refLock counters are also reference counters, but they prevent\n    // garbage collection instead of being used to trigger it\n    refCount = data.refLock.get(currentOptimisticKey);\n    if (!refCount)\n      data.refLock.set(currentOptimisticKey, (refCount = new Map()));\n    links = data.links.optimistic.get(currentOptimisticKey);\n  } else {\n    refCount = data.refCount;\n    links = data.links.base;\n    gc = data.gc;\n  }\n\n  // Retrieve the previous link for this field\n  const prevLinkNode = links && links.get(entityKey);\n  const prevLink = prevLinkNode && prevLinkNode[fieldKey];\n\n  // Update persistence batch and dependencies\n  updateDependencies(entityKey, fieldKey);\n  updatePersist(entityKey, fieldKey);\n  // Update the link\n  setNode(data.links, entityKey, fieldKey, link);\n  // First decrease the reference count for the previous link\n  updateRCForLink(gc, refCount, prevLink, -1);\n  // Then increase the reference count for the new link\n  updateRCForLink(gc, refCount, link, 1);\n};\n\n/** Reserves an optimistic layer and preorders it */\nexport const reserveLayer = (\n  data: InMemoryData,\n  layerKey: number,\n  hasNext?: boolean\n) => {\n  if (hasNext) {\n    data.deferredKeys.add(layerKey);\n  } else {\n    data.deferredKeys.delete(layerKey);\n  }\n\n  let index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) {\n    if (hasNext || !data.commutativeKeys.has(layerKey)) {\n      data.optimisticOrder.splice(index, 1);\n      // Protect optimistic layers from being turned into non-optimistic layers\n      // while preserving optimistic data\n      clearLayer(data, layerKey);\n    } else {\n      return;\n    }\n  }\n\n  // If the layer has future results then we'll move it past any layer that's\n  // still empty, so currently pending operations will take precedence over it\n  for (\n    index = 0;\n    hasNext &&\n    index < data.optimisticOrder.length &&\n    !data.deferredKeys.has(data.optimisticOrder[index]) &&\n    (!data.refLock.has(data.optimisticOrder[index]) ||\n      !data.commutativeKeys.has(data.optimisticOrder[index]));\n    index++\n  );\n\n  data.optimisticOrder.splice(index, 0, layerKey);\n  data.commutativeKeys.add(layerKey);\n};\n\n/** Creates an optimistic layer of links and records */\nconst createLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.optimisticOrder.indexOf(layerKey) === -1) {\n    data.optimisticOrder.unshift(layerKey);\n  }\n\n  if (!data.refLock.has(layerKey)) {\n    data.refLock.set(layerKey, new Map());\n    data.links.optimistic.set(layerKey, new Map());\n    data.records.optimistic.set(layerKey, new Map());\n  }\n};\n\n/** Clears all links and records of an optimistic layer */\nconst clearLayer = (data: InMemoryData, layerKey: number) => {\n  if (data.refLock.has(layerKey)) {\n    data.refLock.delete(layerKey);\n    data.records.optimistic.delete(layerKey);\n    data.links.optimistic.delete(layerKey);\n    data.deferredKeys.delete(layerKey);\n  }\n};\n\n/** Deletes links and records of an optimistic layer, and the layer itself */\nconst deleteLayer = (data: InMemoryData, layerKey: number) => {\n  const index = data.optimisticOrder.indexOf(layerKey);\n  if (index > -1) {\n    data.optimisticOrder.splice(index, 1);\n    data.commutativeKeys.delete(layerKey);\n  }\n\n  clearLayer(data, layerKey);\n};\n\n/** Merges an optimistic layer of links and records into the base data */\nconst squashLayer = (layerKey: number) => {\n  // Hide current dependencies from squashing operations\n  const previousDependencies = currentDependencies;\n  currentDependencies = new Set();\n\n  const links = currentData!.links.optimistic.get(layerKey);\n  if (links) {\n    for (const entry of links.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap)\n        writeLink(entityKey, fieldKey, keyMap[fieldKey]);\n    }\n  }\n\n  const records = currentData!.records.optimistic.get(layerKey);\n  if (records) {\n    for (const entry of records.entries()) {\n      const entityKey = entry[0];\n      const keyMap = entry[1];\n      for (const fieldKey in keyMap)\n        writeRecord(entityKey, fieldKey, keyMap[fieldKey]);\n    }\n  }\n\n  currentDependencies = previousDependencies;\n  deleteLayer(currentData!, layerKey);\n};\n\n/** Return an array of FieldInfo (info on all the fields and their arguments) for a given entity */\nexport const inspectFields = (entityKey: string): FieldInfo[] => {\n  const { links, records } = currentData!;\n  const fieldInfos: FieldInfo[] = [];\n  const seenFieldKeys: Set<string> = new Set();\n  // Update dependencies\n  updateDependencies(entityKey);\n  // Extract FieldInfos to the fieldInfos array for links and records\n  // This also deduplicates by keeping track of fieldKeys in the seenFieldKeys Set\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, links);\n  extractNodeMapFields(fieldInfos, seenFieldKeys, entityKey, records);\n  return fieldInfos;\n};\n\nexport const persistData = () => {\n  if (currentData!.storage) {\n    currentOptimistic = true;\n    currentOperation = 'read';\n    const entries: SerializedEntries = makeDict();\n    for (const key of currentData!.persist.keys()) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      let x: void | Link | EntityField;\n      if ((x = readLink(entityKey, fieldKey)) !== undefined) {\n        entries[key] = `:${stringifyVariables(x)}`;\n      } else if ((x = readRecord(entityKey, fieldKey)) !== undefined) {\n        entries[key] = stringifyVariables(x);\n      } else {\n        entries[key] = undefined;\n      }\n    }\n\n    currentOptimistic = false;\n    currentData!.storage.writeData(entries);\n    currentData!.persist.clear();\n  }\n};\n\nexport const hydrateData = (\n  data: InMemoryData,\n  storage: StorageAdapter,\n  entries: SerializedEntries\n) => {\n  initDataState('write', data, null);\n\n  for (const key in entries) {\n    const value = entries[key];\n    if (value !== undefined) {\n      const { entityKey, fieldKey } = deserializeKeyInfo(key);\n      if (value[0] === ':') {\n        if (readLink(entityKey, fieldKey) === undefined)\n          writeLink(entityKey, fieldKey, JSON.parse(value.slice(1)));\n      } else {\n        if (readRecord(entityKey, fieldKey) === undefined)\n          writeRecord(entityKey, fieldKey, JSON.parse(value));\n      }\n    }\n  }\n\n  clearDataState();\n  data.storage = storage;\n};\n","import { CombinedError } from '@urql/core';\nimport {\n  GraphQLError,\n  FieldNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nimport {\n  isDeferred,\n  isInlineFragment,\n  getTypeCondition,\n  getSelectionSet,\n  getName,\n  SelectionSet,\n  isFieldNode,\n} from '../ast';\n\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\nimport { hasField, isWriting } from '../store/data';\nimport { Store, keyOfField } from '../store';\n\nimport { getFieldArguments, shouldInclude, isInterfaceOfType } from '../ast';\n\nimport {\n  Fragments,\n  Variables,\n  DataField,\n  NullArray,\n  Link,\n  Entity,\n  Data,\n} from '../types';\n\nexport interface Context {\n  store: Store;\n  variables: Variables;\n  fragments: Fragments;\n  parentTypeName: string;\n  parentKey: string;\n  parentFieldKey: string;\n  parent: Data;\n  fieldName: string;\n  error: GraphQLError | undefined;\n  partial: boolean;\n  optimistic: boolean;\n  __internal: {\n    path: Array<string | number>;\n    errorMap: { [path: string]: GraphQLError } | undefined;\n  };\n}\n\nexport const contextRef: { current: Context | null } = { current: null };\nexport const deferRef: { current: boolean } = { current: false };\n\n// Checks whether the current data field is a cache miss because of a GraphQLError\nexport const getFieldError = (ctx: Context): GraphQLError | undefined =>\n  ctx.__internal.path.length > 0 && ctx.__internal.errorMap\n    ? ctx.__internal.errorMap[ctx.__internal.path.join('.')]\n    : undefined;\n\nexport const makeContext = (\n  store: Store,\n  variables: Variables,\n  fragments: Fragments,\n  typename: string,\n  entityKey: string,\n  optimistic?: boolean,\n  error?: CombinedError | undefined\n): Context => {\n  const ctx: Context = {\n    store,\n    variables,\n    fragments,\n    parent: { __typename: typename },\n    parentTypeName: typename,\n    parentKey: entityKey,\n    parentFieldKey: '',\n    fieldName: '',\n    error: undefined,\n    partial: false,\n    optimistic: !!optimistic,\n    __internal: {\n      path: [],\n      errorMap: undefined,\n    },\n  };\n\n  if (error && error.graphQLErrors) {\n    for (let i = 0; i < error.graphQLErrors.length; i++) {\n      const graphQLError = error.graphQLErrors[i];\n      if (graphQLError.path && graphQLError.path.length) {\n        if (!ctx.__internal.errorMap)\n          ctx.__internal.errorMap = Object.create(null);\n        ctx.__internal.errorMap![graphQLError.path.join('.')] = graphQLError;\n      }\n    }\n  }\n\n  return ctx;\n};\n\nexport const updateContext = (\n  ctx: Context,\n  data: Data,\n  typename: string,\n  entityKey: string,\n  fieldKey: string,\n  fieldName: string\n) => {\n  contextRef.current = ctx;\n  ctx.parent = data;\n  ctx.parentTypeName = typename;\n  ctx.parentKey = entityKey;\n  ctx.parentFieldKey = fieldKey;\n  ctx.fieldName = fieldName;\n  ctx.error = getFieldError(ctx);\n};\n\nconst isFragmentHeuristicallyMatching = (\n  node: InlineFragmentNode | FragmentDefinitionNode,\n  typename: void | string,\n  entityKey: string,\n  vars: Variables\n) => {\n  if (!typename) return false;\n  const typeCondition = getTypeCondition(node);\n  if (!typeCondition || typename === typeCondition) return true;\n\n  warn(\n    'Heuristic Fragment Matching: A fragment is trying to match against the `' +\n      typename +\n      '` type, ' +\n      'but the type condition is `' +\n      typeCondition +\n      '`. Since GraphQL allows for interfaces `' +\n      typeCondition +\n      '` may be an' +\n      'interface.\\nA schema needs to be defined for this match to be deterministic, ' +\n      'otherwise the fragment will be matched heuristically!',\n    16\n  );\n\n  return (\n    isWriting() ||\n    !getSelectionSet(node).some(node => {\n      if (!isFieldNode(node)) return false;\n      const fieldKey = keyOfField(getName(node), getFieldArguments(node, vars));\n      return !hasField(entityKey, fieldKey);\n    })\n  );\n};\n\ninterface SelectionIterator {\n  (): FieldNode | undefined;\n}\n\nexport const makeSelectionIterator = (\n  typename: void | string,\n  entityKey: string,\n  select: SelectionSet,\n  ctx: Context\n): SelectionIterator => {\n  let childDeferred = false;\n  let childIterator: SelectionIterator | void;\n  let index = 0;\n\n  return function next() {\n    if (!deferRef.current && childDeferred) deferRef.current = childDeferred;\n\n    if (childIterator) {\n      const node = childIterator();\n      if (node != null) {\n        return node;\n      }\n\n      childIterator = undefined;\n      childDeferred = false;\n      if (process.env.NODE_ENV !== 'production') {\n        popDebugNode();\n      }\n    }\n\n    while (index < select.length) {\n      const node = select[index++];\n      if (!shouldInclude(node, ctx.variables)) {\n        continue;\n      } else if (!isFieldNode(node)) {\n        // A fragment is either referred to by FragmentSpread or inline\n        const fragmentNode = !isInlineFragment(node)\n          ? ctx.fragments[getName(node)]\n          : node;\n\n        if (fragmentNode !== undefined) {\n          const isMatching = ctx.store.schema\n            ? isInterfaceOfType(ctx.store.schema, fragmentNode, typename)\n            : isFragmentHeuristicallyMatching(\n                fragmentNode,\n                typename,\n                entityKey,\n                ctx.variables\n              );\n          if (isMatching) {\n            if (process.env.NODE_ENV !== 'production') {\n              pushDebugNode(typename, fragmentNode);\n            }\n\n            childDeferred = !!isDeferred(node, ctx.variables);\n            if (!deferRef.current && childDeferred)\n              deferRef.current = childDeferred;\n\n            return (childIterator = makeSelectionIterator(\n              typename,\n              entityKey,\n              getSelectionSet(fragmentNode)!,\n              ctx\n            ))();\n          }\n        }\n      } else {\n        return node;\n      }\n    }\n  };\n};\n\nexport const ensureData = (x: DataField): Data | NullArray<Data> | null =>\n  x == null ? null : (x as Data | NullArray<Data>);\n\nexport const ensureLink = (store: Store, ref: Link<Entity>): Link => {\n  if (ref == null) {\n    return ref;\n  } else if (Array.isArray(ref)) {\n    const link = new Array(ref.length);\n    for (let i = 0, l = link.length; i < l; i++)\n      link[i] = ensureLink(store, ref[i]);\n    return link;\n  }\n\n  const link = store.keyOfEntity(ref);\n  if (!link && ref && typeof ref === 'object') {\n    warn(\n      \"Can't generate a key for link(...) item.\" +\n        '\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        ref.__typename +\n        '`.',\n      12\n    );\n  }\n\n  return link;\n};\n","import { FieldNode, DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { CombinedError } from '@urql/core';\n\nimport {\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n  isFieldAvailableOnType,\n  getSelectionSet,\n  getName,\n  SelectionSet,\n  getFragmentTypeName,\n  getFieldAlias,\n} from '../ast';\n\nimport { invariant, warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport {\n  NullArray,\n  Variables,\n  Data,\n  Link,\n  OperationRequest,\n  Dependencies,\n  EntityField,\n  OptimisticMutationResolver,\n} from '../types';\n\nimport {\n  Store,\n  getCurrentDependencies,\n  initDataState,\n  clearDataState,\n  joinKeys,\n  keyOfField,\n} from '../store';\n\nimport * as InMemoryData from '../store/data';\n\nimport {\n  Context,\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n} from './shared';\n\nexport interface WriteResult {\n  data: null | Data;\n  dependencies: Dependencies;\n}\n\n/** Writes a request given its response to the store */\nexport const write = (\n  store: Store,\n  request: OperationRequest,\n  data: Data,\n  error?: CombinedError | undefined,\n  key?: number\n): WriteResult => {\n  initDataState('write', store.data, key || null);\n  const result = startWrite(store, request, data, error);\n  clearDataState();\n  return result;\n};\n\nexport const writeOptimistic = (\n  store: Store,\n  request: OperationRequest,\n  key: number\n): WriteResult => {\n  if (process.env.NODE_ENV !== 'production') {\n    invariant(\n      getMainOperation(request.query).operation === 'mutation',\n      'writeOptimistic(...) was called with an operation that is not a mutation.\\n' +\n        'This case is unsupported and should never occur.',\n      10\n    );\n  }\n\n  initDataState('write', store.data, key, true);\n  const result = startWrite(store, request, {} as Data, undefined, true);\n  clearDataState();\n  return result;\n};\n\nexport const startWrite = (\n  store: Store,\n  request: OperationRequest,\n  data: Data,\n  error?: CombinedError | undefined,\n  isOptimistic?: boolean\n) => {\n  const operation = getMainOperation(request.query);\n  const result: WriteResult = { data, dependencies: getCurrentDependencies() };\n  const kind = store.rootFields[operation.operation];\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(request.query),\n    kind,\n    kind,\n    !!isOptimistic,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(kind, operation);\n  }\n\n  writeSelection(ctx, kind, getSelectionSet(operation), data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nexport const writeFragment = (\n  store: Store,\n  query: DocumentNode,\n  data: Partial<Data>,\n  variables?: Variables,\n  fragmentName?: string\n) => {\n  const fragments = getFragments(query);\n  let fragment: FragmentDefinitionNode;\n  if (fragmentName) {\n    fragment = fragments[fragmentName] as FragmentDefinitionNode;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        11\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]] as FragmentDefinitionNode;\n    if (!fragment) {\n      warn(\n        'writeFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        11\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  const dataToWrite = { __typename: typename, ...data } as Data;\n  const entityKey = store.keyOfEntity(dataToWrite);\n  if (!entityKey) {\n    return warn(\n      \"Can't generate a key for writeFragment(...) data.\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      12\n    );\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey,\n    undefined\n  );\n\n  writeSelection(ctx, entityKey, getSelectionSet(fragment), dataToWrite);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n};\n\nconst writeSelection = (\n  ctx: Context,\n  entityKey: undefined | string,\n  select: SelectionSet,\n  data: Data\n) => {\n  const isQuery = entityKey === ctx.store.rootFields['query'];\n  const isRoot = !isQuery && !!ctx.store.rootNames[entityKey!];\n  const typename = isRoot || isQuery ? entityKey : data.__typename;\n  if (!typename) {\n    warn(\n      \"Couldn't find __typename when writing.\\n\" +\n        \"If you're writing to the cache manually have to pass a `__typename` property on each entity in your data.\",\n      14\n    );\n    return;\n  } else if (!isRoot && !isQuery && entityKey) {\n    InMemoryData.writeRecord(entityKey, '__typename', typename);\n  }\n\n  const iterate = makeSelectionIterator(\n    typename,\n    entityKey || typename,\n    select,\n    ctx\n  );\n\n  let node: FieldNode | void;\n  while ((node = iterate())) {\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const fieldAlias = getFieldAlias(node);\n    let fieldValue = data[ctx.optimistic ? fieldName : fieldAlias];\n\n    // Development check of undefined fields\n    if (process.env.NODE_ENV !== 'production') {\n      if (\n        !isRoot &&\n        fieldValue === undefined &&\n        !deferRef.current &&\n        !ctx.optimistic\n      ) {\n        const expected =\n          node.selectionSet === undefined\n            ? 'scalar (number, boolean, etc)'\n            : 'selection set';\n\n        warn(\n          'Invalid undefined: The field at `' +\n            fieldKey +\n            '` is `undefined`, but the GraphQL query expects a ' +\n            expected +\n            ' for this field.',\n          13\n        );\n\n        continue; // Skip this field\n      } else if (ctx.store.schema && typename && fieldName !== '__typename') {\n        isFieldAvailableOnType(ctx.store.schema, typename, fieldName);\n      }\n    }\n\n    if (\n      // Skip typename fields and assume they've already been written above\n      fieldName === '__typename' ||\n      // Fields marked as deferred that aren't defined must be skipped\n      (fieldValue === undefined && deferRef.current)\n    ) {\n      continue;\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n\n    // Execute optimistic mutation functions on root fields, or execute recursive functions\n    // that have been returned on optimistic objects\n    let resolver: OptimisticMutationResolver | void;\n    if (ctx.optimistic && isRoot) {\n      resolver = ctx.store.optimisticMutations[fieldName];\n      if (!resolver) continue;\n    } else if (ctx.optimistic && typeof fieldValue === 'function') {\n      resolver = fieldValue as any;\n    }\n\n    // Execute the field-level resolver to retrieve its data\n    if (resolver) {\n      // We have to update the context to reflect up-to-date ResolveInfo\n      updateContext(ctx, data, typename, typename, fieldKey, fieldName);\n      fieldValue = ensureData(resolver(fieldArgs || {}, ctx.store, ctx));\n    }\n\n    if (node.selectionSet) {\n      // Process the field and write links for the child entities that have been written\n      if (entityKey && !isRoot) {\n        const key = joinKeys(entityKey, fieldKey);\n        const link = writeField(\n          ctx,\n          getSelectionSet(node),\n          ensureData(fieldValue),\n          key\n        );\n        InMemoryData.writeLink(entityKey || typename, fieldKey, link);\n      } else {\n        writeField(ctx, getSelectionSet(node), ensureData(fieldValue));\n      }\n    } else if (entityKey && !isRoot) {\n      // This is a leaf node, so we're setting the field's value directly\n      InMemoryData.writeRecord(\n        entityKey || typename,\n        fieldKey,\n        (fieldValue !== null || !getFieldError(ctx)\n          ? fieldValue\n          : undefined) as EntityField\n      );\n    }\n\n    if (isRoot) {\n      // We run side-effect updates after the default, normalized updates\n      // so that the data is already available in-store if necessary\n      const updater = ctx.store.updates[typename][fieldName];\n      if (updater) {\n        // We have to update the context to reflect up-to-date ResolveInfo\n        updateContext(\n          ctx,\n          data,\n          typename,\n          typename,\n          joinKeys(typename, fieldKey),\n          fieldName\n        );\n\n        data[fieldName] = fieldValue;\n        updater(data, fieldArgs || {}, ctx.store, ctx);\n      }\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n};\n\n// A pattern to match typenames of types that are likely never keyable\nconst KEYLESS_TYPE_RE = /^__|PageInfo|(Connection|Edge)$/;\n\nconst writeField = (\n  ctx: Context,\n  select: SelectionSet,\n  data: null | Data | NullArray<Data>,\n  parentFieldKey?: string\n): Link | undefined => {\n  if (Array.isArray(data)) {\n    const newData = new Array(data.length);\n    for (let i = 0, l = data.length; i < l; i++) {\n      // Add the current index to the walked path before processing the link\n      ctx.__internal.path.push(i);\n      // Append the current index to the parentFieldKey fallback\n      const indexKey = parentFieldKey\n        ? joinKeys(parentFieldKey, `${i}`)\n        : undefined;\n      // Recursively write array data\n      const links = writeField(ctx, select, data[i], indexKey);\n      // Link cannot be expressed as a recursive type\n      newData[i] = links as string | null;\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return newData;\n  } else if (data === null) {\n    return getFieldError(ctx) ? undefined : null;\n  }\n\n  const entityKey = ctx.store.keyOfEntity(data);\n  const typename = data.__typename;\n\n  if (\n    parentFieldKey &&\n    !ctx.store.keys[data.__typename] &&\n    entityKey === null &&\n    typeof typename === 'string' &&\n    !KEYLESS_TYPE_RE.test(typename)\n  ) {\n    warn(\n      'Invalid key: The GraphQL query at the field at `' +\n        parentFieldKey +\n        '` has a selection set, ' +\n        'but no key could be generated for the data at this field.\\n' +\n        'You have to request `id` or `_id` fields for all selection sets or create ' +\n        'a custom `keys` config for `' +\n        typename +\n        '`.\\n' +\n        'Entities without keys will be embedded directly on the parent entity. ' +\n        'If this is intentional, create a `keys` config for `' +\n        typename +\n        '` that always returns null.',\n      15\n    );\n  }\n\n  const childKey = entityKey || parentFieldKey;\n  writeSelection(ctx, childKey, select, data);\n  return childKey || null;\n};\n","import * as InMemoryData from '../store/data';\nimport { FieldArgs } from '../types';\nimport { keyOfField } from '../store';\n\ninterface PartialFieldInfo {\n  fieldKey: string;\n}\n\nexport const invalidateEntity = (\n  entityKey: string,\n  field?: string,\n  args?: FieldArgs\n) => {\n  const fields: PartialFieldInfo[] = field\n    ? [{ fieldKey: keyOfField(field, args) }]\n    : InMemoryData.inspectFields(entityKey);\n\n  for (let i = 0, l = fields.length; i < l; i++) {\n    const { fieldKey } = fields[i];\n    if (InMemoryData.readLink(entityKey, fieldKey) !== undefined) {\n      InMemoryData.writeLink(entityKey, fieldKey, undefined);\n    } else {\n      InMemoryData.writeRecord(entityKey, fieldKey, undefined);\n    }\n  }\n};\n","import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode, formatDocument, createRequest } from '@urql/core';\n\nimport {\n  Cache,\n  FieldInfo,\n  ResolverConfig,\n  DataField,\n  Variables,\n  FieldArgs,\n  Link,\n  Data,\n  QueryInput,\n  UpdateResolver,\n  OptimisticMutationConfig,\n  KeyingConfig,\n  Entity,\n  CacheExchangeOpts,\n} from '../types';\n\nimport { invariant } from '../helpers/help';\nimport { contextRef, ensureLink } from '../operations/shared';\nimport { read, readFragment } from '../operations/query';\nimport { writeFragment, startWrite } from '../operations/write';\nimport { invalidateEntity } from '../operations/invalidate';\nimport { keyOfField } from './keys';\nimport * as InMemoryData from './data';\n\nimport {\n  SchemaIntrospector,\n  buildClientSchema,\n  expectValidKeyingConfig,\n  expectValidUpdatesConfig,\n  expectValidResolversConfig,\n  expectValidOptimisticMutationsConfig,\n} from '../ast';\n\ntype RootField = 'query' | 'mutation' | 'subscription';\n\nexport class Store<\n  C extends Partial<CacheExchangeOpts> = Partial<CacheExchangeOpts>\n> implements Cache {\n  data: InMemoryData.InMemoryData;\n\n  resolvers: ResolverConfig;\n  updates: Record<string, Record<string, UpdateResolver | undefined>>;\n  optimisticMutations: OptimisticMutationConfig;\n  keys: KeyingConfig;\n  schema?: SchemaIntrospector;\n\n  rootFields: { query: string; mutation: string; subscription: string };\n  rootNames: { [name: string]: RootField };\n\n  constructor(opts?: C) {\n    if (!opts) opts = {} as C;\n\n    this.resolvers = opts.resolvers || {};\n    this.optimisticMutations = opts.optimistic || {};\n    this.keys = opts.keys || {};\n\n    let queryName = 'Query';\n    let mutationName = 'Mutation';\n    let subscriptionName = 'Subscription';\n    if (opts.schema) {\n      const schema = buildClientSchema(opts.schema);\n      queryName = schema.query || queryName;\n      mutationName = schema.mutation || mutationName;\n      subscriptionName = schema.subscription || subscriptionName;\n      // Only add schema introspector if it has types info\n      if (schema.types) this.schema = schema;\n    }\n\n    this.updates = {\n      [mutationName]: (opts.updates && opts.updates.Mutation) || {},\n      [subscriptionName]: (opts.updates && opts.updates.Subscription) || {},\n    };\n\n    this.rootFields = {\n      query: queryName,\n      mutation: mutationName,\n      subscription: subscriptionName,\n    };\n\n    this.rootNames = {\n      [queryName]: 'query',\n      [mutationName]: 'mutation',\n      [subscriptionName]: 'subscription',\n    };\n\n    this.data = InMemoryData.make(queryName);\n\n    if (this.schema && process.env.NODE_ENV !== 'production') {\n      expectValidKeyingConfig(this.schema, this.keys);\n      expectValidUpdatesConfig(this.schema, this.updates);\n      expectValidResolversConfig(this.schema, this.resolvers);\n      expectValidOptimisticMutationsConfig(\n        this.schema,\n        this.optimisticMutations\n      );\n    }\n  }\n\n  keyOfField = keyOfField;\n\n  keyOfEntity(data: Entity) {\n    // In resolvers and updaters we may have a specific parent\n    // object available that can be used to skip to a specific parent\n    // key directly without looking at its incomplete properties\n    if (contextRef.current && data === contextRef.current.parent)\n      return contextRef.current!.parentKey;\n\n    if (data == null || typeof data === 'string') return data || null;\n    if (!data.__typename) return null;\n    if (this.rootNames[data.__typename]) return data.__typename;\n\n    let key: string | null | void;\n    if (this.keys[data.__typename]) {\n      key = this.keys[data.__typename](data);\n    } else if (data.id != null) {\n      key = `${data.id}`;\n    } else if (data._id != null) {\n      key = `${data._id}`;\n    }\n\n    return key ? `${data.__typename}:${key}` : null;\n  }\n\n  resolve(entity: Entity, field: string, args?: FieldArgs): DataField {\n    const fieldKey = keyOfField(field, args);\n    const entityKey = this.keyOfEntity(entity);\n    if (!entityKey) return null;\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    if (fieldValue !== undefined) return fieldValue;\n    const link = InMemoryData.readLink(entityKey, fieldKey);\n    return link || null;\n  }\n\n  resolveFieldByKey = this.resolve;\n\n  invalidate(entity: Entity, field?: string, args?: FieldArgs) {\n    const entityKey = this.keyOfEntity(entity);\n\n    invariant(\n      entityKey,\n      \"Can't generate a key for invalidate(...).\\n\" +\n        'You have to pass an id or _id field or create a custom `keys` field for `' +\n        typeof entity ===\n        'object'\n        ? (entity as Data).__typename\n        : entity + '`.',\n      19\n    );\n\n    invalidateEntity(entityKey, field, args);\n  }\n\n  inspectFields(entity: Entity): FieldInfo[] {\n    const entityKey = this.keyOfEntity(entity);\n    return entityKey ? InMemoryData.inspectFields(entityKey) : [];\n  }\n\n  updateQuery<T = Data, V = Variables>(\n    input: QueryInput<T, V>,\n    updater: (data: T | null) => T | null\n  ): void {\n    const request = createRequest<T, V>(input.query, input.variables as any);\n    request.query = formatDocument(request.query);\n    const output = updater(this.readQuery(request));\n    if (output !== null) {\n      startWrite(this, request, output as any);\n    }\n  }\n\n  readQuery<T = Data, V = Variables>(input: QueryInput<T, V>): T | null {\n    const request = createRequest(input.query, input.variables!);\n    request.query = formatDocument(request.query);\n    return read(this, request).data as T | null;\n  }\n\n  readFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    entity: string | Data | T,\n    variables?: V,\n    fragmentName?: string\n  ): T | null {\n    return readFragment(\n      this,\n      formatDocument(fragment),\n      entity,\n      variables as any,\n      fragmentName\n    ) as T | null;\n  }\n\n  writeFragment<T = Data, V = Variables>(\n    fragment: DocumentNode | TypedDocumentNode<T, V>,\n    data: T,\n    variables?: V,\n    fragmentName?: string\n  ): void {\n    writeFragment(\n      this,\n      formatDocument(fragment),\n      data,\n      variables as any,\n      fragmentName\n    );\n  }\n\n  link(\n    entity: Entity,\n    field: string,\n    args: FieldArgs,\n    link: Link<Entity>\n  ): void;\n\n  link(entity: Entity, field: string, link: Link<Entity>): void;\n\n  link(\n    entity: Entity,\n    field: string,\n    argsOrLink: FieldArgs | Link<Entity>,\n    maybeLink?: Link<Entity>\n  ): void {\n    const args = (maybeLink !== undefined ? argsOrLink : null) as FieldArgs;\n    const link = (maybeLink !== undefined\n      ? maybeLink\n      : argsOrLink) as Link<Entity>;\n    const entityKey = ensureLink(this, entity);\n    if (typeof entityKey === 'string') {\n      InMemoryData.writeLink(\n        entityKey,\n        keyOfField(field, args),\n        ensureLink(this, link)\n      );\n    }\n  }\n}\n","import { FieldNode, DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { CombinedError } from '@urql/core';\n\nimport {\n  getSelectionSet,\n  getName,\n  SelectionSet,\n  getFragmentTypeName,\n  getFieldAlias,\n  getFragments,\n  getMainOperation,\n  normalizeVariables,\n  getFieldArguments,\n} from '../ast';\n\nimport {\n  Variables,\n  Data,\n  DataField,\n  Link,\n  OperationRequest,\n  Dependencies,\n} from '../types';\n\nimport {\n  Store,\n  getCurrentOperation,\n  getCurrentDependencies,\n  initDataState,\n  clearDataState,\n  joinKeys,\n  keyOfField,\n  makeData,\n  ownsData,\n} from '../store';\n\nimport * as InMemoryData from '../store/data';\nimport { warn, pushDebugNode, popDebugNode } from '../helpers/help';\n\nimport {\n  Context,\n  makeSelectionIterator,\n  ensureData,\n  makeContext,\n  updateContext,\n  getFieldError,\n  deferRef,\n} from './shared';\n\nimport {\n  isFieldAvailableOnType,\n  isFieldNullable,\n  isListNullable,\n} from '../ast';\n\nexport interface QueryResult {\n  dependencies: Dependencies;\n  partial: boolean;\n  data: null | Data;\n}\n\nexport const query = (\n  store: Store,\n  request: OperationRequest,\n  data?: Data | null | undefined,\n  error?: CombinedError | undefined,\n  key?: number\n): QueryResult => {\n  initDataState('read', store.data, key);\n  const result = read(store, request, data, error);\n  clearDataState();\n  return result;\n};\n\nexport const read = (\n  store: Store,\n  request: OperationRequest,\n  input?: Data | null | undefined,\n  error?: CombinedError | undefined\n): QueryResult => {\n  const operation = getMainOperation(request.query);\n  const rootKey = store.rootFields[operation.operation];\n  const rootSelect = getSelectionSet(operation);\n\n  const ctx = makeContext(\n    store,\n    normalizeVariables(operation, request.variables),\n    getFragments(request.query),\n    rootKey,\n    rootKey,\n    false,\n    error\n  );\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(rootKey, operation);\n  }\n\n  if (!input) input = makeData();\n  // NOTE: This may reuse \"previous result data\" as indicated by the\n  // `originalData` argument in readRoot(). This behaviour isn't used\n  // for readSelection() however, which always produces results from\n  // scratch\n  const data =\n    rootKey !== ctx.store.rootFields['query']\n      ? readRoot(ctx, rootKey, rootSelect, input)\n      : readSelection(ctx, rootKey, rootSelect, input);\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return {\n    dependencies: getCurrentDependencies(),\n    partial: ctx.partial || !data,\n    data: data || null,\n  };\n};\n\nconst readRoot = (\n  ctx: Context,\n  entityKey: string,\n  select: SelectionSet,\n  input: Data\n): Data => {\n  const typename = ctx.store.rootNames[entityKey]\n    ? entityKey\n    : input.__typename;\n  if (typeof typename !== 'string') {\n    return input;\n  }\n\n  const iterate = makeSelectionIterator(entityKey, entityKey, select, ctx);\n\n  let node: FieldNode | void;\n  let hasChanged = false;\n  const output = makeData(input);\n  while ((node = iterate())) {\n    const fieldAlias = getFieldAlias(node);\n    const fieldValue = input[fieldAlias];\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField;\n    if (node.selectionSet && fieldValue !== null) {\n      dataFieldValue = readRootField(\n        ctx,\n        getSelectionSet(node),\n        ensureData(fieldValue)\n      );\n    } else {\n      dataFieldValue = fieldValue;\n    }\n\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== fieldValue;\n    if (dataFieldValue !== undefined) output[fieldAlias] = dataFieldValue!;\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n  }\n\n  return hasChanged ? output : input;\n};\n\nconst readRootField = (\n  ctx: Context,\n  select: SelectionSet,\n  originalData: Link<Data>\n): Link<Data> => {\n  if (Array.isArray(originalData)) {\n    const newData = new Array(originalData.length);\n    let hasChanged = false;\n    for (let i = 0, l = originalData.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the root field's value\n      newData[i] = readRootField(ctx, select, originalData[i]);\n      hasChanged = hasChanged || newData[i] !== originalData[i];\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n    }\n\n    return hasChanged ? newData : originalData;\n  } else if (originalData === null) {\n    return null;\n  }\n\n  // Write entity to key that falls back to the given parentFieldKey\n  const entityKey = ctx.store.keyOfEntity(originalData);\n  if (entityKey !== null) {\n    // We assume that since this is used for result data this can never be undefined,\n    // since the result data has already been written to the cache\n    return readSelection(ctx, entityKey, select, originalData) || null;\n  } else {\n    return readRoot(ctx, originalData.__typename, select, originalData);\n  }\n};\n\nexport const readFragment = (\n  store: Store,\n  query: DocumentNode,\n  entity: Partial<Data> | string,\n  variables?: Variables,\n  fragmentName?: string\n): Data | null => {\n  const fragments = getFragments(query);\n\n  let fragment: FragmentDefinitionNode;\n  if (fragmentName) {\n    fragment = fragments[fragmentName] as FragmentDefinitionNode;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with a fragment name that does not exist.\\n' +\n          'You provided ' +\n          fragmentName +\n          ' but could only find ' +\n          Object.keys(fragments).join(', ') +\n          '.',\n        6\n      );\n\n      return null;\n    }\n  } else {\n    const names = Object.keys(fragments);\n    fragment = fragments[names[0]] as FragmentDefinitionNode;\n    if (!fragment) {\n      warn(\n        'readFragment(...) was called with an empty fragment.\\n' +\n          'You have to call it with at least one fragment in your GraphQL document.',\n        6\n      );\n\n      return null;\n    }\n  }\n\n  const typename = getFragmentTypeName(fragment);\n  if (typeof entity !== 'string' && !entity.__typename)\n    entity.__typename = typename;\n  const entityKey = store.keyOfEntity(entity as Data);\n  if (!entityKey) {\n    warn(\n      \"Can't generate a key for readFragment(...).\\n\" +\n        'You have to pass an `id` or `_id` field or create a custom `keys` config for `' +\n        typename +\n        '`.',\n      7\n    );\n\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    pushDebugNode(typename, fragment);\n  }\n\n  const ctx = makeContext(\n    store,\n    variables || {},\n    fragments,\n    typename,\n    entityKey\n  );\n\n  const result =\n    readSelection(ctx, entityKey, getSelectionSet(fragment), makeData()) ||\n    null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    popDebugNode();\n  }\n\n  return result;\n};\n\nconst readSelection = (\n  ctx: Context,\n  key: string,\n  select: SelectionSet,\n  input: Data,\n  result?: Data\n): Data | undefined => {\n  const { store } = ctx;\n  const isQuery = key === store.rootFields['query'];\n\n  const entityKey = (result && store.keyOfEntity(result)) || key;\n  if (!isQuery && !!ctx.store.rootNames[entityKey]) {\n    warn(\n      'Invalid root traversal: A selection was being read on `' +\n        entityKey +\n        '` which is an uncached root type.\\n' +\n        'The `' +\n        ctx.store.rootFields.mutation +\n        '` and `' +\n        ctx.store.rootFields.subscription +\n        '` types are special ' +\n        'Operation Root Types and cannot be read back from the cache.',\n      25\n    );\n  }\n\n  const typename = !isQuery\n    ? InMemoryData.readRecord(entityKey, '__typename') ||\n      (result && result.__typename)\n    : key;\n\n  if (typeof typename !== 'string') {\n    return;\n  } else if (result && typename !== result.__typename) {\n    warn(\n      'Invalid resolver data: The resolver at `' +\n        entityKey +\n        '` returned an ' +\n        'invalid typename that could not be reconciled with the cache.',\n      8\n    );\n\n    return;\n  }\n\n  const iterate = makeSelectionIterator(typename, entityKey, select, ctx);\n\n  let hasFields = false;\n  let hasPartials = false;\n  let hasChanged = typename !== input.__typename;\n  let node: FieldNode | void;\n  const output = makeData(input);\n  while ((node = iterate()) !== undefined) {\n    // Derive the needed data from our node.\n    const fieldName = getName(node);\n    const fieldArgs = getFieldArguments(node, ctx.variables);\n    const fieldAlias = getFieldAlias(node);\n    const fieldKey = keyOfField(fieldName, fieldArgs);\n    const key = joinKeys(entityKey, fieldKey);\n    const fieldValue = InMemoryData.readRecord(entityKey, fieldKey);\n    const resultValue = result ? result[fieldName] : undefined;\n    const resolvers = store.resolvers[typename];\n\n    if (process.env.NODE_ENV !== 'production' && store.schema && typename) {\n      isFieldAvailableOnType(store.schema, typename, fieldName);\n    }\n\n    // Add the current alias to the walked path before processing the field's value\n    ctx.__internal.path.push(fieldAlias);\n    // We temporarily store the data field in here, but undefined\n    // means that the value is missing from the cache\n    let dataFieldValue: void | DataField;\n\n    if (fieldName === '__typename') {\n      // We directly assign the typename as it's already available\n      dataFieldValue = typename;\n    } else if (resultValue !== undefined && node.selectionSet === undefined) {\n      // The field is a scalar and can be retrieved directly from the result\n      dataFieldValue = resultValue;\n    } else if (\n      getCurrentOperation() === 'read' &&\n      resolvers &&\n      typeof resolvers[fieldName] === 'function'\n    ) {\n      // We have to update the information in context to reflect the info\n      // that the resolver will receive\n      updateContext(ctx, output, typename, entityKey, key, fieldName);\n\n      // We have a resolver for this field.\n      // Prepare the actual fieldValue, so that the resolver can use it\n      if (fieldValue !== undefined) {\n        output[fieldAlias] = fieldValue;\n      }\n\n      dataFieldValue = resolvers[fieldName](\n        output,\n        fieldArgs || ({} as Variables),\n        store,\n        ctx\n      );\n\n      if (node.selectionSet) {\n        // When it has a selection set we are resolving an entity with a\n        // subselection. This can either be a list or an object.\n        dataFieldValue = resolveResolverResult(\n          ctx,\n          typename,\n          fieldName,\n          key,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          dataFieldValue,\n          ownsData(input)\n        );\n      }\n\n      if (\n        store.schema &&\n        dataFieldValue === null &&\n        !isFieldNullable(store.schema, typename, fieldName)\n      ) {\n        // Special case for when null is not a valid value for the\n        // current field\n        return undefined;\n      }\n    } else if (!node.selectionSet) {\n      // The field is a scalar but isn't on the result, so it's retrieved from the cache\n      dataFieldValue = fieldValue;\n    } else if (resultValue !== undefined) {\n      // We start walking the nested resolver result here\n      dataFieldValue = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        key,\n        getSelectionSet(node),\n        (output[fieldAlias] !== undefined\n          ? output[fieldAlias]\n          : input[fieldAlias]) as Data,\n        resultValue,\n        ownsData(input)\n      );\n    } else {\n      // Otherwise we attempt to get the missing field from the cache\n      const link = InMemoryData.readLink(entityKey, fieldKey);\n\n      if (link !== undefined) {\n        dataFieldValue = resolveLink(\n          ctx,\n          link,\n          typename,\n          fieldName,\n          getSelectionSet(node),\n          (output[fieldAlias] !== undefined\n            ? output[fieldAlias]\n            : input[fieldAlias]) as Data,\n          ownsData(input)\n        );\n      } else if (typeof fieldValue === 'object' && fieldValue !== null) {\n        // The entity on the field was invalid but can still be recovered\n        dataFieldValue = fieldValue;\n      }\n    }\n\n    // Now that dataFieldValue has been retrieved it'll be set on data\n    // If it's uncached (undefined) but nullable we can continue assembling\n    // a partial query result\n    if (dataFieldValue === undefined && deferRef.current) {\n      // The field is undelivered and uncached, but is included in a deferred fragment\n      hasFields = true;\n    } else if (\n      dataFieldValue === undefined &&\n      ((store.schema && isFieldNullable(store.schema, typename, fieldName)) ||\n        !!getFieldError(ctx))\n    ) {\n      // The field is uncached or has errored, so it'll be set to null and skipped\n      hasPartials = true;\n      dataFieldValue = null;\n    } else if (dataFieldValue === undefined) {\n      // If the field isn't deferred or partial then we have to abort\n      ctx.__internal.path.pop();\n      return undefined;\n    } else {\n      // Otherwise continue as usual\n      hasFields = hasFields || fieldName !== '__typename';\n    }\n\n    // After processing the field, remove the current alias from the path again\n    ctx.__internal.path.pop();\n    // Check for any referential changes in the field's value\n    hasChanged = hasChanged || dataFieldValue !== input[fieldAlias];\n    if (dataFieldValue !== undefined) output[fieldAlias] = dataFieldValue;\n  }\n\n  ctx.partial = ctx.partial || hasPartials;\n  return isQuery && hasPartials && !hasFields\n    ? undefined\n    : hasChanged\n    ? output\n    : input;\n};\n\nconst resolveResolverResult = (\n  ctx: Context,\n  typename: string,\n  fieldName: string,\n  key: string,\n  select: SelectionSet,\n  prevData: void | null | Data | Data[],\n  result: void | DataField,\n  skipNull: boolean\n): DataField | void => {\n  if (Array.isArray(result)) {\n    const { store } = ctx;\n    // Check whether values of the list may be null; for resolvers we assume\n    // that they can be, since it's user-provided data\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName)\n      : false;\n    const data = new Array(result.length);\n    let hasChanged =\n      !Array.isArray(prevData) || result.length !== prevData.length;\n    for (let i = 0, l = result.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read resolver result\n      const childResult = resolveResolverResult(\n        ctx,\n        typename,\n        fieldName,\n        joinKeys(key, `${i}`),\n        select,\n        prevData != null ? prevData[i] : undefined,\n        result[i],\n        skipNull\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childResult === undefined && !_isListNullable) {\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childResult === undefined && _isListNullable);\n        data[i] = childResult != null ? childResult : null;\n        hasChanged = hasChanged || data[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? data : prevData;\n  } else if (result === null || result === undefined) {\n    return result;\n  } else if (skipNull && prevData === null) {\n    return null;\n  } else if (isDataOrKey(result)) {\n    const data = (prevData || makeData()) as Data;\n    return typeof result === 'string'\n      ? readSelection(ctx, result, select, data)\n      : readSelection(ctx, key, select, data, result);\n  } else {\n    warn(\n      'Invalid resolver value: The field at `' +\n        key +\n        '` is a scalar (number, boolean, etc)' +\n        ', but the GraphQL query expects a selection set for this field.',\n      9\n    );\n\n    return undefined;\n  }\n};\n\nconst resolveLink = (\n  ctx: Context,\n  link: Link | Link[],\n  typename: string,\n  fieldName: string,\n  select: SelectionSet,\n  prevData: void | null | Data | Data[],\n  skipNull: boolean\n): DataField | undefined => {\n  if (Array.isArray(link)) {\n    const { store } = ctx;\n    const _isListNullable = store.schema\n      ? isListNullable(store.schema, typename, fieldName)\n      : false;\n    const newLink = new Array(link.length);\n    let hasChanged =\n      !Array.isArray(prevData) || newLink.length !== prevData.length;\n    for (let i = 0, l = link.length; i < l; i++) {\n      // Add the current index to the walked path before reading the field's value\n      ctx.__internal.path.push(i);\n      // Recursively read the link\n      const childLink = resolveLink(\n        ctx,\n        link[i],\n        typename,\n        fieldName,\n        select,\n        prevData != null ? prevData[i] : undefined,\n        skipNull\n      );\n      // After processing the field, remove the current index from the path\n      ctx.__internal.path.pop();\n      // Check the result for cache-missed values\n      if (childLink === undefined && !_isListNullable) {\n        return undefined;\n      } else {\n        ctx.partial =\n          ctx.partial || (childLink === undefined && _isListNullable);\n        newLink[i] = childLink || null;\n        hasChanged = hasChanged || newLink[i] !== prevData![i];\n      }\n    }\n\n    return hasChanged ? newLink : (prevData as Data[]);\n  } else if (link === null || (prevData === null && skipNull)) {\n    return null;\n  }\n\n  return readSelection(ctx, link, select, (prevData || makeData()) as Data);\n};\n\nconst isDataOrKey = (x: any): x is string | Data =>\n  typeof x === 'string' ||\n  (typeof x === 'object' && typeof (x as any).__typename === 'string');\n","import {\n  Operation,\n  RequestPolicy,\n  CacheOutcome,\n  makeOperation,\n} from '@urql/core';\n\n// Returns the given operation result with added cacheOutcome meta field\nexport const addCacheOutcome = (\n  operation: Operation,\n  outcome: CacheOutcome\n): Operation =>\n  makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      cacheOutcome: outcome,\n    },\n  });\n\n// Copy an operation and change the requestPolicy to skip the cache\nexport const toRequestPolicy = (\n  operation: Operation,\n  requestPolicy: RequestPolicy\n): Operation => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    requestPolicy,\n  });\n};\n","import {\n  Exchange,\n  formatDocument,\n  makeOperation,\n  Operation,\n  OperationResult,\n  RequestPolicy,\n  CacheOutcome,\n} from '@urql/core';\n\nimport {\n  filter,\n  map,\n  merge,\n  pipe,\n  share,\n  fromArray,\n  mergeMap,\n  empty,\n  Source,\n} from 'wonka';\n\nimport { query, write, writeOptimistic } from './operations';\nimport { addCacheOutcome, toRequestPolicy } from './helpers/operation';\nimport { filterVariables, getMainOperation } from './ast';\nimport { Store, noopDataState, hydrateData, reserveLayer } from './store';\nimport { Data, Dependencies, CacheExchangeOpts } from './types';\n\ntype OperationResultWithMeta = OperationResult & {\n  outcome: CacheOutcome;\n  dependencies: Dependencies;\n};\n\ntype Operations = Set<number>;\ntype OperationMap = Map<number, Operation>;\ntype ResultMap = Map<number, Data | null>;\ntype OptimisticDependencies = Map<number, Dependencies>;\ntype DependentOperations = Map<string, Operations>;\n\nexport const cacheExchange = <C extends Partial<CacheExchangeOpts>>(\n  opts?: C\n): Exchange => ({ forward, client, dispatchDebug }) => {\n  const store = new Store<C>(opts);\n\n  if (opts && opts.storage) {\n    opts.storage.readData().then(entries => {\n      hydrateData(store.data, opts!.storage!, entries);\n    });\n  }\n\n  const optimisticKeysToDependencies: OptimisticDependencies = new Map();\n  const mutationResultBuffer: OperationResult[] = [];\n  const operations: OperationMap = new Map();\n  const results: ResultMap = new Map();\n  const blockedDependencies: Dependencies = new Set();\n  const requestedRefetch: Operations = new Set();\n  const deps: DependentOperations = new Map();\n\n  const isBlockedByOptimisticUpdate = (dependencies: Dependencies): boolean => {\n    for (const dep of dependencies.values())\n      if (blockedDependencies.has(dep)) return true;\n    return false;\n  };\n\n  const collectPendingOperations = (\n    pendingOperations: Operations,\n    dependencies: undefined | Dependencies\n  ) => {\n    if (dependencies) {\n      // Collect operations that will be updated due to cache changes\n      for (const dep of dependencies.values()) {\n        const keys = deps.get(dep);\n        if (keys) for (const key of keys.values()) pendingOperations.add(key);\n      }\n    }\n  };\n\n  const executePendingOperations = (\n    operation: Operation,\n    pendingOperations: Operations\n  ) => {\n    // Reexecute collected operations and delete them from the mapping\n    for (const key of pendingOperations.values()) {\n      if (key !== operation.key) {\n        const op = operations.get(key);\n        if (op) {\n          operations.delete(key);\n          let policy: RequestPolicy = 'cache-first';\n          if (requestedRefetch.has(key)) {\n            requestedRefetch.delete(key);\n            policy = 'cache-and-network';\n          }\n          client.reexecuteOperation(toRequestPolicy(op, policy));\n        }\n      }\n    }\n  };\n\n  // This registers queries with the data layer to ensure commutativity\n  const prepareForwardedOperation = (operation: Operation) => {\n    if (operation.kind === 'query') {\n      // Pre-reserve the position of the result layer\n      reserveLayer(store.data, operation.key);\n    } else if (operation.kind === 'teardown') {\n      // Delete reference to operation if any exists to release it\n      operations.delete(operation.key);\n      results.delete(operation.key);\n      // Mark operation layer as done\n      noopDataState(store.data, operation.key);\n    } else if (\n      operation.kind === 'mutation' &&\n      operation.context.requestPolicy !== 'network-only'\n    ) {\n      // This executes an optimistic update for mutations and registers it if necessary\n      const { dependencies } = writeOptimistic(store, operation, operation.key);\n      if (dependencies.size) {\n        // Update blocked optimistic dependencies\n        for (const dep of dependencies.values()) blockedDependencies.add(dep);\n\n        // Store optimistic dependencies for update\n        optimisticKeysToDependencies.set(operation.key, dependencies);\n\n        // Update related queries\n        const pendingOperations: Operations = new Set();\n        collectPendingOperations(pendingOperations, dependencies);\n        executePendingOperations(operation, pendingOperations);\n      }\n    }\n\n    return makeOperation(\n      operation.kind,\n      {\n        key: operation.key,\n        query: formatDocument(operation.query),\n        variables: operation.variables\n          ? filterVariables(\n              getMainOperation(operation.query),\n              operation.variables\n            )\n          : operation.variables,\n      },\n      operation.context\n    );\n  };\n\n  // This updates the known dependencies for the passed operation\n  const updateDependencies = (op: Operation, dependencies: Dependencies) => {\n    for (const dep of dependencies.values()) {\n      let depOps = deps.get(dep);\n      if (!depOps) deps.set(dep, (depOps = new Set()));\n      depOps.add(op.key);\n      operations.set(op.key, op);\n    }\n  };\n\n  // Retrieves a query result from cache and adds an `isComplete` hint\n  // This hint indicates whether the result is \"complete\" or not\n  const operationResultFromCache = (\n    operation: Operation\n  ): OperationResultWithMeta => {\n    const result = query(store, operation, results.get(operation.key));\n    const cacheOutcome: CacheOutcome = result.data\n      ? !result.partial\n        ? 'hit'\n        : 'partial'\n      : 'miss';\n\n    results.set(operation.key, result.data);\n    updateDependencies(operation, result.dependencies);\n\n    return {\n      outcome: cacheOutcome,\n      operation,\n      data: result.data,\n      dependencies: result.dependencies,\n    };\n  };\n\n  // Take any OperationResult and update the cache with it\n  const updateCacheWithResult = (\n    result: OperationResult,\n    pendingOperations: Operations\n  ): OperationResult => {\n    const { operation, error, extensions } = result;\n    const { key } = operation;\n\n    if (operation.kind === 'mutation') {\n      // Collect previous dependencies that have been written for optimistic updates\n      const dependencies = optimisticKeysToDependencies.get(key);\n      collectPendingOperations(pendingOperations, dependencies);\n      optimisticKeysToDependencies.delete(key);\n    }\n\n    reserveLayer(\n      store.data,\n      operation.key,\n      operation.kind === 'subscription' || result.hasNext\n    );\n\n    let queryDependencies: void | Dependencies;\n    let data: Data | null = result.data;\n    if (data) {\n      // Write the result to cache and collect all dependencies that need to be\n      // updated\n      const writeDependencies = write(store, operation, data, result.error, key)\n        .dependencies;\n      collectPendingOperations(pendingOperations, writeDependencies);\n\n      const queryResult = query(\n        store,\n        operation,\n        operation.kind === 'query' ? results.get(operation.key) || data : data,\n        result.error,\n        key\n      );\n\n      data = queryResult.data;\n      if (operation.kind === 'query') {\n        // Collect the query's dependencies for future pending operation updates\n        queryDependencies = queryResult.dependencies;\n        collectPendingOperations(pendingOperations, queryDependencies);\n        results.set(operation.key, result.data);\n      }\n    } else {\n      noopDataState(store.data, operation.key);\n    }\n\n    // Update this operation's dependencies if it's a query\n    if (queryDependencies) {\n      updateDependencies(result.operation, queryDependencies);\n    }\n\n    return { data, error, extensions, operation };\n  };\n\n  return ops$ => {\n    const sharedOps$ = pipe(ops$, share);\n\n    // Filter by operations that are cacheable and attempt to query them from the cache\n    const cacheOps$ = pipe(\n      sharedOps$,\n      filter(op => {\n        return (\n          op.kind === 'query' && op.context.requestPolicy !== 'network-only'\n        );\n      }),\n      map(operationResultFromCache),\n      share\n    );\n\n    const nonCacheOps$ = pipe(\n      sharedOps$,\n      filter(op => {\n        return (\n          op.kind !== 'query' || op.context.requestPolicy === 'network-only'\n        );\n      })\n    );\n\n    // Rebound operations that are incomplete, i.e. couldn't be queried just from the cache\n    const cacheMissOps$ = pipe(\n      cacheOps$,\n      filter(res => {\n        return (\n          res.outcome === 'miss' &&\n          res.operation.context.requestPolicy !== 'cache-only' &&\n          !isBlockedByOptimisticUpdate(res.dependencies)\n        );\n      }),\n      map(res => {\n        dispatchDebug({\n          type: 'cacheMiss',\n          message: 'The result could not be retrieved from the cache',\n          operation: res.operation,\n        });\n        return addCacheOutcome(res.operation, 'miss');\n      })\n    );\n\n    // Resolve OperationResults that the cache was able to assemble completely and trigger\n    // a network request if the current operation's policy is cache-and-network\n    const cacheResult$ = pipe(\n      cacheOps$,\n      filter(\n        res =>\n          res.outcome !== 'miss' ||\n          res.operation.context.requestPolicy === 'cache-only'\n      ),\n      map(\n        (res: OperationResultWithMeta): OperationResult => {\n          const { operation, outcome, dependencies } = res;\n          const result: OperationResult = {\n            operation: addCacheOutcome(operation, outcome),\n            data: res.data,\n            error: res.error,\n            extensions: res.extensions,\n          };\n\n          if (\n            operation.context.requestPolicy === 'cache-and-network' ||\n            (operation.context.requestPolicy === 'cache-first' &&\n              outcome === 'partial')\n          ) {\n            result.stale = true;\n            if (!isBlockedByOptimisticUpdate(dependencies)) {\n              client.reexecuteOperation(\n                toRequestPolicy(operation, 'network-only')\n              );\n            } else if (\n              operation.context.requestPolicy === 'cache-and-network'\n            ) {\n              requestedRefetch.add(operation.key);\n            }\n          }\n\n          dispatchDebug({\n            type: 'cacheHit',\n            message: `A requested operation was found and returned from the cache.`,\n            operation: res.operation,\n            data: {\n              value: result,\n            },\n          });\n\n          return result;\n        }\n      )\n    );\n\n    // Forward operations that aren't cacheable and rebound operations\n    // Also update the cache with any network results\n    const result$ = pipe(\n      merge([nonCacheOps$, cacheMissOps$]),\n      map(prepareForwardedOperation),\n      forward,\n      share\n    );\n\n    // Results that can immediately be resolved\n    const nonOptimisticResults$ = pipe(\n      result$,\n      filter(result => !optimisticKeysToDependencies.has(result.operation.key)),\n      map(result => {\n        const pendingOperations: Operations = new Set();\n        // Update the cache with the incoming API result\n        const cacheResult = updateCacheWithResult(result, pendingOperations);\n        // Execute all dependent queries\n        executePendingOperations(result.operation, pendingOperations);\n        return cacheResult;\n      })\n    );\n\n    // Prevent mutations that were previously optimistic from being flushed\n    // immediately and instead clear them out slowly\n    const optimisticMutationCompletion$ = pipe(\n      result$,\n      filter(result => optimisticKeysToDependencies.has(result.operation.key)),\n      mergeMap(\n        (result: OperationResult): Source<OperationResult> => {\n          const length = mutationResultBuffer.push(result);\n          if (length < optimisticKeysToDependencies.size) {\n            return empty;\n          }\n\n          for (let i = 0; i < mutationResultBuffer.length; i++) {\n            reserveLayer(store.data, mutationResultBuffer[i].operation.key);\n          }\n\n          blockedDependencies.clear();\n\n          const results: OperationResult[] = [];\n          const pendingOperations: Operations = new Set();\n\n          let bufferedResult: OperationResult | void;\n          while ((bufferedResult = mutationResultBuffer.shift()))\n            results.push(\n              updateCacheWithResult(bufferedResult, pendingOperations)\n            );\n\n          // Execute all dependent queries as a single batch\n          executePendingOperations(result.operation, pendingOperations);\n\n          return fromArray(results);\n        }\n      )\n    );\n\n    return merge([\n      nonOptimisticResults$,\n      optimisticMutationCompletion$,\n      cacheResult$,\n    ]);\n  };\n};\n","import { pipe, merge, makeSubject, share, filter, tap } from 'wonka';\nimport { print, SelectionNode } from 'graphql';\n\nimport {\n  Operation,\n  Exchange,\n  ExchangeIO,\n  CombinedError,\n  createRequest,\n  makeOperation,\n} from '@urql/core';\n\nimport {\n  getMainOperation,\n  getFragments,\n  isInlineFragment,\n  isFieldNode,\n  shouldInclude,\n  getSelectionSet,\n  getName,\n} from './ast';\n\nimport {\n  SerializedRequest,\n  OptimisticMutationConfig,\n  Variables,\n  CacheExchangeOpts,\n} from './types';\n\nimport { cacheExchange } from './cacheExchange';\nimport { toRequestPolicy } from './helpers/operation';\n\n/** Determines whether a given query contains an optimistic mutation field */\nconst isOptimisticMutation = <T extends OptimisticMutationConfig>(\n  config: T,\n  operation: Operation\n) => {\n  const vars: Variables = operation.variables || {};\n  const fragments = getFragments(operation.query);\n  const selections = [...getSelectionSet(getMainOperation(operation.query))];\n\n  let field: void | SelectionNode;\n  while ((field = selections.pop())) {\n    if (!shouldInclude(field, vars)) {\n      continue;\n    } else if (!isFieldNode(field)) {\n      const fragmentNode = !isInlineFragment(field)\n        ? fragments[getName(field)]\n        : field;\n      if (fragmentNode) selections.push(...getSelectionSet(fragmentNode));\n    } else if (config[getName(field)]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst isOfflineError = (error: undefined | CombinedError) =>\n  error &&\n  error.networkError &&\n  !error.response &&\n  ((typeof navigator !== 'undefined' && navigator.onLine === false) ||\n    /request failed|failed to fetch|network\\s?error/i.test(\n      error.networkError.message\n    ));\n\nexport const offlineExchange = <C extends Partial<CacheExchangeOpts>>(\n  opts: C\n): Exchange => input => {\n  const { storage } = opts;\n  if (\n    storage &&\n    storage.onOnline &&\n    storage.readMetadata &&\n    storage.writeMetadata\n  ) {\n    const { forward: outerForward, client, dispatchDebug } = input;\n    const { source: reboundOps$, next } = makeSubject<Operation>();\n    const optimisticMutations = opts.optimistic || {};\n    const failedQueue: Operation[] = [];\n\n    const updateMetadata = () => {\n      const requests: SerializedRequest[] = [];\n      for (let i = 0; i < failedQueue.length; i++) {\n        const operation = failedQueue[i];\n        if (operation.kind === 'mutation') {\n          requests.push({\n            query: print(operation.query),\n            variables: operation.variables,\n          });\n        }\n      }\n      storage.writeMetadata!(requests);\n    };\n\n    let isFlushingQueue = false;\n    const flushQueue = () => {\n      if (!isFlushingQueue) {\n        isFlushingQueue = true;\n\n        for (let i = 0; i < failedQueue.length; i++) {\n          const operation = failedQueue[i];\n          if (operation.kind === 'mutation') {\n            next(makeOperation('teardown', operation));\n          }\n        }\n\n        for (let i = 0; i < failedQueue.length; i++)\n          client.reexecuteOperation(failedQueue[i]);\n\n        failedQueue.length = 0;\n        isFlushingQueue = false;\n        updateMetadata();\n      }\n    };\n\n    const forward: ExchangeIO = ops$ => {\n      return pipe(\n        outerForward(ops$),\n        filter(res => {\n          if (\n            res.operation.kind === 'mutation' &&\n            isOfflineError(res.error) &&\n            isOptimisticMutation(optimisticMutations, res.operation)\n          ) {\n            failedQueue.push(\n              incomingMutations.get(res.operation.context._instance as []) ||\n                res.operation\n            );\n            updateMetadata();\n            return false;\n          }\n\n          if (res.operation.kind === 'mutation' && !res.error) {\n            incomingMutations.delete(res.operation.context._instance as []);\n          }\n\n          return true;\n        })\n      );\n    };\n\n    storage.onOnline(flushQueue);\n    storage.readMetadata().then(mutations => {\n      if (mutations) {\n        for (let i = 0; i < mutations.length; i++) {\n          failedQueue.push(\n            client.createRequestOperation(\n              'mutation',\n              createRequest(mutations[i].query, mutations[i].variables)\n            )\n          );\n        }\n\n        flushQueue();\n      }\n    });\n\n    const cacheResults$ = cacheExchange({\n      ...opts,\n      storage: {\n        ...storage,\n        readData() {\n          return storage.readData().finally(flushQueue);\n        },\n      },\n    })({\n      client,\n      dispatchDebug,\n      forward,\n    });\n\n    const incomingMutations = new WeakMap<[], Operation>();\n    return ops$ => {\n      const sharedOps$ = pipe(\n        ops$,\n        tap(operation => {\n          if (operation.kind === 'mutation') {\n            incomingMutations.set(operation.context._instance as [], operation);\n          }\n        }),\n        share\n      );\n\n      const opsAndRebound$ = merge([reboundOps$, sharedOps$]);\n\n      return pipe(\n        cacheResults$(opsAndRebound$),\n        filter(res => {\n          if (res.operation.kind === 'query' && isOfflineError(res.error)) {\n            next(toRequestPolicy(res.operation, 'cache-only'));\n            failedQueue.push(res.operation);\n            return false;\n          }\n\n          return true;\n        })\n      );\n    };\n  }\n\n  return cacheExchange(opts)(input);\n};\n"],"names":["getName","node","name","value","getFragmentTypeName","typeCondition","getFieldAlias","alias","emptySelectionSet","getSelectionSet","selectionSet","selections","getTypeCondition","isFieldNode","kind","Kind","FIELD","isInlineFragment","INLINE_FRAGMENT","getFieldArguments","vars","i","l","arguments","length","undefined","args","filterVariables","input","variableDefinitions","variable","normalizeVariables","key","helpUrl","cache","Set","currentDebugStack","popDebugNode","pop","pushDebugNode","typename","identifier","OPERATION_DEFINITION","FRAGMENT_DEFINITION","push","getDebugOutput","invariant","condition","message","code","process","env","NODE_ENV","error","warn","has","console","add","getMainOperation","doc","definitions","getFragments","fragments","shouldInclude","directives","directive","valueFromASTUntyped","isDeferred","j","argument","buildClientSchema","__schema","typemap","Map","buildNameMap","arr","map","buildType","type","fields","field","schema","query","queryType","mutation","mutationType","subscriptionType","types","abstractType","possibleType","out","BUILTIN_NAME","isFieldNullable","fieldName","isListNullable","ofType","isFieldAvailableOnType","indexOf","isInterfaceOfType","expectAbstractType","expectObjectType","getField","get","expectValidKeyingConfig","keys","expectValidUpdatesConfig","updates","mutationFields","givenMutations","subscriptionFields","subscription","givenSubscription","warnAboutResolver","warnAboutAbstractResolver","expectValidResolversConfig","resolvers","validQueries","resolverQuery","Query","validTypeProperties","resolverProperty","expectValidOptimisticMutationsConfig","optimisticMutations","validMutations","keyOfField","stringifyVariables","joinKeys","parentKey","fieldInfoOfKey","fieldKey","parenIndex","JSON","parse","slice","serializeKeys","entityKey","replace","deserializeKeyInfo","dotIndex","makeDict","Object","create","currentOwnership","currentDataMapping","currentOperation","currentData","currentDependencies","currentOptimisticKey","currentOptimistic","makeData","data","newData","set","isWriting","ownsData","initDataState","operationType","layerKey","isOptimistic","WeakSet","WeakMap","commutativeKeys","reserveLayer","optimisticOrder","splice","delete","createLayer","deleteLayer","clearDataState","getCurrentDependencies","deferredKeys","defer","gc","persistData","noopDataState","getCurrentOperation","make","queryRootKey","links","records","storage","setNode","base","keymap","entity","getNode","skip","optimistic","updateRCForEntity","refCount","by","newCount","count","updateRCForLink","link","Array","isArray","extractNodeFields","fieldInfos","seenFieldKeys","extractNodeMapFields","batch","rc","linkNode","updateDependencies","updatePersist","persist","readRecord","readLink","writeRecord","hasField","writeLink","refLock","hasNext","index","clearLayer","unshift","squashLayer","entry","entries","keyMap","inspectFields","x","writeData","clear","hydrateData","contextRef","current","deferRef","getFieldError","ctx","__internal","path","errorMap","join","makeContext","store","variables","parent","__typename","parentTypeName","parentFieldKey","partial","graphQLErrors","graphQLError","updateContext","isFragmentHeuristicallyMatching","makeSelectionIterator","select","childIterator","next","childDeferred","fragmentNode","isMatching","ensureData","ensureLink","ref","write","request","result","startWrite","writeOptimistic","operation","writeSelection","writeFragment","fragmentName","fragment","dataToWrite","isQuery","rootFields","isRoot","rootNames","iterate","fieldAlias","fieldValue","expected","resolver","fieldArgs","writeField","InMemoryData","updater","KEYLESS_TYPE_RE","indexKey","test","childKey","invalidateEntity","Store","constructor","opts","prototype","__init","call","__init2","queryName","mutationName","subscriptionName","Mutation","Subscription","keyOfEntity","id","_id","resolve","resolveFieldByKey","invalidate","createRequest","output","readQuery","readFragment","formatDocument","argsOrLink","maybeLink","read","rootSelect","rootKey","readRoot","dataFieldValue","readRootField","hasChanged","originalData","readSelection","resultValue","hasFields","hasPartials","resolveResolverResult","prevData","skipNull","_isListNullable","childResult","isDataOrKey","resolveLink","newLink","childLink","addCacheOutcome","outcome","makeOperation","meta","context","cacheOutcome","toRequestPolicy","requestPolicy","cacheExchange","forward","client","dispatchDebug","optimisticKeysToDependencies","operations","results","blockedDependencies","requestedRefetch","deps","isBlockedByOptimisticUpdate","dependencies","dep","values","collectPendingOperations","pendingOperations","executePendingOperations","op","prepareForwardedOperation","depOps","operationResultFromCache","updateCacheWithResult","queryDependencies","writeDependencies","queryResult","res","cacheResult$","stale","filter","cacheOps$","nonOptimisticResults$","cacheResult","result$","optimisticMutationCompletion$","mergeMap","size","empty","mutationResultBuffer","bufferedResult","shift","fromArray","merge","isOptimisticMutation","config","isOfflineError","networkError","offlineExchange","onOnline","readMetadata","failedQueue","print","writeMetadata","requests","updateMetadata","ops$","incomingMutations","_instance","flushQueue","mutations","share"],"mappings":"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"}