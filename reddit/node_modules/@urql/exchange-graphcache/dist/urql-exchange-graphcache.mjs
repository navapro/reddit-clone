import { stringifyVariables as e, createRequest as r, formatDocument as t, makeOperation as i } from "@urql/core";

import { share as a, map as n, filter as o, merge as s, mergeMap as v, empty as l, fromArray as u, makeSubject as d, tap as p } from "wonka";

import { Kind as c, valueFromASTUntyped as f, print as y } from "graphql";

var getName = e => e.name.value;

var getFragmentTypeName = e => e.typeCondition.name.value;

var getFieldAlias = e => e.alias ? e.alias.value : e.name.value;

var h = [];

var getSelectionSet = e => e.selectionSet ? e.selectionSet.selections : h;

var getTypeCondition = e => e.typeCondition ? e.typeCondition.name.value : null;

var isFieldNode = e => e.kind === c.FIELD;

var isInlineFragment = e => e.kind === c.INLINE_FRAGMENT;

var getFieldArguments = (e, r) => {
  var t = null;
  if (e.arguments) {
    for (var i = 0, a = e.arguments.length; i < a; i++) {
      var n = e.arguments[i];
      var o = f(n.value, r);
      if (null != o) {
        if (!t) {
          t = {};
        }
        t[getName(n)] = o;
      }
    }
  }
  return t;
};

var filterVariables = (e, r) => {
  if (!r || !e.variableDefinitions) {
    return;
  }
  var t = {};
  for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {
    var n = getName(e.variableDefinitions[i].variable);
    t[n] = r[n];
  }
  return t;
};

var normalizeVariables = (e, r) => {
  var t = {};
  if (!r) {
    return t;
  }
  if (e.variableDefinitions) {
    for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {
      var n = e.variableDefinitions[i];
      var o = getName(n.variable);
      t[o] = void 0 === r[o] && n.defaultValue ? f(n.defaultValue, r) : r[o];
    }
  }
  for (var s in r) {
    if (!(s in t)) {
      t[s] = r[s];
    }
  }
  return t;
};

var m = "\nhttps://bit.ly/2XbVrpR#";

var _ = new Set;

var g = [];

var popDebugNode = () => g.pop();

var pushDebugNode = (e, r) => {
  var t = "";
  if (r.kind === c.INLINE_FRAGMENT) {
    t = e ? `Inline Fragment on "${e}"` : "Inline Fragment";
  } else if (r.kind === c.OPERATION_DEFINITION) {
    t = `${r.name ? `"${r.name.value}"` : "Unnamed"} ${r.operation}`;
  } else if (r.kind === c.FRAGMENT_DEFINITION) {
    t = `"${r.name.value}" Fragment`;
  }
  if (t) {
    g.push(t);
  }
};

var getDebugOutput = () => g.length ? "\n(Caused At: " + g.join(", ") + ")" : "";

function invariant(e, r, t) {
  if (!e) {
    var i = r || "Minfied Error #" + t + "\n";
    if ("production" !== process.env.NODE_ENV) {
      i += getDebugOutput();
    }
    var a = new Error(i + m + t);
    a.name = "Graphcache Error";
    throw a;
  }
}

function warn(e, r) {
  if (!_.has(e)) {
    console.warn(e + getDebugOutput() + m + r);
    _.add(e);
  }
}

var getMainOperation = e => {
  for (var r = 0; r < e.definitions.length; r++) {
    if (e.definitions[r].kind === c.OPERATION_DEFINITION) {
      return e.definitions[r];
    }
  }
  invariant(!1, "production" !== process.env.NODE_ENV ? "Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation." : "", 1);
};

var getFragments = e => {
  var r = {};
  for (var t = 0; t < e.definitions.length; t++) {
    var i = e.definitions[t];
    if (i.kind === c.FRAGMENT_DEFINITION) {
      r[getName(i)] = i;
    }
  }
  return r;
};

var shouldInclude = (e, r) => {
  for (var t = 0; e.directives && t < e.directives.length; t++) {
    var i = e.directives[t];
    var a = getName(i);
    if (("include" === a || "skip" === a) && i.arguments && i.arguments[0] && "if" === getName(i.arguments[0])) {
      var n = f(i.arguments[0].value, r);
      return "include" === a ? !!n : !n;
    }
  }
  return !0;
};

var isDeferred = (e, r) => {
  for (var t = 0; e.directives && t < e.directives.length; t++) {
    var i = e.directives[t];
    if ("defer" === getName(i)) {
      for (var a = 0; i.arguments && a < i.arguments.length; a++) {
        var n = i.arguments[t];
        if ("if" === getName(n)) {
          return !!f(n.value, r);
        }
      }
      return !0;
    }
  }
  return !1;
};

var isFieldNullable = (e, r, t) => {
  var i = getField(e, r, t);
  return !!i && "NON_NULL" !== i.type.kind;
};

var isListNullable = (e, r, t) => {
  var i = getField(e, r, t);
  if (!i) {
    return !1;
  }
  var a = "NON_NULL" === i.type.kind ? i.type.ofType : i.type;
  return "LIST" === a.kind && "NON_NULL" !== a.ofType.kind;
};

var isFieldAvailableOnType = (e, r, t) => 0 === t.indexOf("__") || 0 === r.indexOf("__") || !!getField(e, r, t);

var isInterfaceOfType = (e, r, t) => {
  if (!t) {
    return !1;
  }
  var i = getTypeCondition(r);
  if (!i || t === i) {
    return !0;
  } else if (e.types.has(i) && "OBJECT" === e.types.get(i).kind) {
    return i === t;
  }
  !function expectAbstractType(e, r) {
    invariant(e.types.has(r) && ("INTERFACE" === e.types.get(r).kind || "UNION" === e.types.get(r).kind), "production" !== process.env.NODE_ENV ? "Invalid Abstract type: The type `" + r + "` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition." : "", 5);
  }(e, i);
  expectObjectType(e, t);
  return e.isSubType(i, t);
};

var getField = (e, r, t) => {
  if (0 === t.indexOf("__") || 0 === r.indexOf("__")) {
    return;
  }
  expectObjectType(e, r);
  var i = e.types.get(r).fields()[t];
  if ("production" !== process.env.NODE_ENV) {
    if (!i) {
      warn("Invalid field: The field `" + t + "` does not exist on `" + r + "`, but the GraphQL document expects it to exist.\nTraversal will continue, however this may lead to undefined behavior!", 4);
    }
  }
  return i;
};

function expectObjectType(e, r) {
  invariant(e.types.has(r) && "OBJECT" === e.types.get(r).kind, "production" !== process.env.NODE_ENV ? "Invalid Object type: The type `" + r + "` is not an object in the defined schema, but the GraphQL document is traversing it." : "", 3);
}

function warnAboutResolver(e) {
  "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${e}\` is not in the defined schema, but the \`resolvers\` option is referencing it.`, 23);
}

var keyOfField = (r, t) => t ? `${r}(${e(t)})` : r;

var joinKeys = (e, r) => `${e}.${r}`;

var fieldInfoOfKey = e => {
  var r = e.indexOf("(");
  if (r > -1) {
    return {
      fieldKey: e,
      fieldName: e.slice(0, r),
      arguments: JSON.parse(e.slice(r + 1, -1))
    };
  } else {
    return {
      fieldKey: e,
      fieldName: e,
      arguments: null
    };
  }
};

var deserializeKeyInfo = e => {
  var r = e.indexOf(".");
  return {
    entityKey: e.slice(0, r).replace(/%2e/g, "."),
    fieldKey: e.slice(r + 1)
  };
};

var makeDict = () => Object.create(null);

var N = null;

var E = null;

var O = null;

var k = null;

var w = null;

var b = null;

var D = !1;

var makeData = e => {
  var r;
  if (e) {
    if (N.has(e)) {
      return e;
    }
    r = E.get(e) || {
      ...e
    };
    E.set(e, r);
  } else {
    r = {};
  }
  N.add(r);
  return r;
};

var ownsData = e => !!e && N.has(e);

var initDataState = (e, r, t, i) => {
  N = new WeakSet;
  E = new WeakMap;
  O = e;
  k = r;
  w = new Set;
  D = !!i;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if (!t) {
    b = null;
  } else if ("read" === O) {
    b = t;
  } else if (i || r.optimisticOrder.length > 1) {
    if (!i && !r.commutativeKeys.has(t)) {
      reserveLayer(r, t);
    } else if (i) {
      if (-1 !== r.optimisticOrder.indexOf(t) && !r.commutativeKeys.has(t)) {
        r.optimisticOrder.splice(r.optimisticOrder.indexOf(t), 1);
      }
      r.commutativeKeys.delete(t);
    }
    b = t;
    createLayer(r, t);
  } else {
    b = null;
    deleteLayer(r, t);
  }
};

var clearDataState = () => {
  if ("production" !== process.env.NODE_ENV) {
    getCurrentDependencies();
  }
  var e = k;
  var r = b;
  D = !1;
  b = null;
  if (r && e.optimisticOrder.indexOf(r) > -1) {
    var t = e.optimisticOrder.length;
    while (--t >= 0 && e.refLock.has(e.optimisticOrder[t]) && e.commutativeKeys.has(e.optimisticOrder[t]) && !e.deferredKeys.has(e.optimisticOrder[t])) {
      squashLayer(e.optimisticOrder[t]);
    }
  }
  N = null;
  E = null;
  O = null;
  k = null;
  w = null;
  if ("production" !== process.env.NODE_ENV) {
    g.length = 0;
  }
  if ("test" !== process.env.NODE_ENV && !e.defer) {
    e.defer = !0;
    setTimeout((() => {
      initDataState("read", e, null);
      gc();
      persistData();
      clearDataState();
      e.defer = !1;
    }));
  }
};

var noopDataState = (e, r, t) => {
  if (r && !t) {
    e.deferredKeys.delete(r);
  }
  initDataState("write", e, r, t);
  clearDataState();
};

var getCurrentOperation = () => {
  invariant(null !== O, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return O;
};

var getCurrentDependencies = () => {
  invariant(null !== w, "production" !== process.env.NODE_ENV ? "Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs." : "", 2);
  return w;
};

var setNode = (e, r, t, i) => {
  var a = b ? e.optimistic.get(b) : e.base;
  var n = a.get(r);
  if (void 0 === n) {
    a.set(r, n = makeDict());
  }
  if (void 0 === i && !b) {
    delete n[t];
  } else {
    n[t] = i;
  }
};

var getNode = (e, r, t) => {
  var i;
  var a = !D && "read" === O && b && k.commutativeKeys.has(b);
  for (var n = 0, o = k.optimisticOrder.length; n < o; n++) {
    var s = k.optimisticOrder[n];
    var v = e.optimistic.get(s);
    a = a && s !== b;
    if (v && (!a || !k.commutativeKeys.has(s)) && (!D || "write" === O || k.commutativeKeys.has(s)) && void 0 !== (i = v.get(r)) && t in i) {
      return i[t];
    }
  }
  return void 0 !== (i = e.base.get(r)) ? i[t] : void 0;
};

var updateRCForEntity = (e, r, t, i) => {
  var a = r.get(t) || 0;
  var n = a + i;
  r.set(t, n);
  if (e) {
    if (n <= 0) {
      e.add(t);
    } else if (a <= 0 && n > 0) {
      e.delete(t);
    }
  }
};

var updateRCForLink = (e, r, t, i) => {
  if ("string" == typeof t) {
    updateRCForEntity(e, r, t, i);
  } else if (Array.isArray(t)) {
    for (var a = 0, n = t.length; a < n; a++) {
      if (Array.isArray(t[a])) {
        updateRCForLink(e, r, t[a], i);
      } else if (t[a]) {
        updateRCForEntity(e, r, t[a], i);
      }
    }
  }
};

var extractNodeFields = (e, r, t) => {
  if (void 0 !== t) {
    for (var i in t) {
      if (!r.has(i)) {
        e.push(fieldInfoOfKey(i));
        r.add(i);
      }
    }
  }
};

var extractNodeMapFields = (e, r, t, i) => {
  extractNodeFields(e, r, i.base.get(t));
  for (var a = 0, n = k.optimisticOrder.length; a < n; a++) {
    var o = i.optimistic.get(k.optimisticOrder[a]);
    if (void 0 !== o) {
      extractNodeFields(e, r, o.get(t));
    }
  }
};

var gc = () => {
  var {gc: e} = k;
  for (var r of e.keys()) {
    if ((k.refCount.get(r) || 0) > 0) {
      e.delete(r);
      return;
    }
    for (var t of k.refLock.keys()) {
      var i = k.refLock.get(t);
      if (i) {
        if ((i.get(r) || 0) > 0) {
          return;
        }
        i.delete(r);
      }
    }
    k.refCount.delete(r);
    e.delete(r);
    k.records.base.delete(r);
    var a = k.links.base.get(r);
    if (a) {
      k.links.base.delete(r);
      for (var n in a) {
        updateRCForLink(e, k.refCount, a[n], -1);
      }
    }
  }
};

var updateDependencies = (e, r) => {
  if ("__typename" !== r) {
    if (e !== k.queryRootKey) {
      w.add(e);
    } else if (void 0 !== r) {
      w.add(joinKeys(e, r));
    }
  }
};

var updatePersist = (e, r) => {
  if (!D && k.storage) {
    k.persist.add(((e, r) => `${e.replace(/\./g, "%2e")}.${r}`)(e, r));
  }
};

var readRecord = (e, r) => {
  updateDependencies(e, r);
  return getNode(k.records, e, r);
};

var readLink = (e, r) => {
  updateDependencies(e, r);
  return getNode(k.links, e, r);
};

var writeRecord = (e, r, t) => {
  updateDependencies(e, r);
  updatePersist(e, r);
  setNode(k.records, e, r, t);
};

var writeLink = (e, r, t) => {
  var i = k;
  var a;
  var n;
  var o;
  if (b) {
    if (!(a = i.refLock.get(b))) {
      i.refLock.set(b, a = new Map);
    }
    n = i.links.optimistic.get(b);
  } else {
    a = i.refCount;
    n = i.links.base;
    o = i.gc;
  }
  var s = n && n.get(e);
  var v = s && s[r];
  updateDependencies(e, r);
  updatePersist(e, r);
  setNode(i.links, e, r, t);
  updateRCForLink(o, a, v, -1);
  updateRCForLink(o, a, t, 1);
};

var reserveLayer = (e, r, t) => {
  if (t) {
    e.deferredKeys.add(r);
  } else {
    e.deferredKeys.delete(r);
  }
  var i = e.optimisticOrder.indexOf(r);
  if (i > -1) {
    if (t || !e.commutativeKeys.has(r)) {
      e.optimisticOrder.splice(i, 1);
      clearLayer(e, r);
    } else {
      return;
    }
  }
  for (i = 0; t && i < e.optimisticOrder.length && !e.deferredKeys.has(e.optimisticOrder[i]) && (!e.refLock.has(e.optimisticOrder[i]) || !e.commutativeKeys.has(e.optimisticOrder[i])); i++) {}
  e.optimisticOrder.splice(i, 0, r);
  e.commutativeKeys.add(r);
};

var createLayer = (e, r) => {
  if (-1 === e.optimisticOrder.indexOf(r)) {
    e.optimisticOrder.unshift(r);
  }
  if (!e.refLock.has(r)) {
    e.refLock.set(r, new Map);
    e.links.optimistic.set(r, new Map);
    e.records.optimistic.set(r, new Map);
  }
};

var clearLayer = (e, r) => {
  if (e.refLock.has(r)) {
    e.refLock.delete(r);
    e.records.optimistic.delete(r);
    e.links.optimistic.delete(r);
    e.deferredKeys.delete(r);
  }
};

var deleteLayer = (e, r) => {
  var t = e.optimisticOrder.indexOf(r);
  if (t > -1) {
    e.optimisticOrder.splice(t, 1);
    e.commutativeKeys.delete(r);
  }
  clearLayer(e, r);
};

var squashLayer = e => {
  var r = w;
  w = new Set;
  var t = k.links.optimistic.get(e);
  if (t) {
    for (var i of t.entries()) {
      var a = i[0];
      var n = i[1];
      for (var o in n) {
        writeLink(a, o, n[o]);
      }
    }
  }
  var s = k.records.optimistic.get(e);
  if (s) {
    for (var v of s.entries()) {
      var l = v[0];
      var u = v[1];
      for (var d in u) {
        writeRecord(l, d, u[d]);
      }
    }
  }
  w = r;
  deleteLayer(k, e);
};

var inspectFields = e => {
  var {links: r, records: t} = k;
  var i = [];
  var a = new Set;
  updateDependencies(e);
  extractNodeMapFields(i, a, e, r);
  extractNodeMapFields(i, a, e, t);
  return i;
};

var persistData = () => {
  if (k.storage) {
    D = !0;
    O = "read";
    var r = makeDict();
    for (var t of k.persist.keys()) {
      var {entityKey: i, fieldKey: a} = deserializeKeyInfo(t);
      var n = void 0;
      if (void 0 !== (n = readLink(i, a))) {
        r[t] = `:${e(n)}`;
      } else if (void 0 !== (n = readRecord(i, a))) {
        r[t] = e(n);
      } else {
        r[t] = void 0;
      }
    }
    D = !1;
    k.storage.writeData(r);
    k.persist.clear();
  }
};

var V = {
  current: null
};

var q = {
  current: !1
};

var getFieldError = e => e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(".")] : void 0;

var makeContext = (e, r, t, i, a, n, o) => {
  var s = {
    store: e,
    variables: r,
    fragments: t,
    parent: {
      __typename: i
    },
    parentTypeName: i,
    parentKey: a,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: !1,
    optimistic: !!n,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (o && o.graphQLErrors) {
    for (var v = 0; v < o.graphQLErrors.length; v++) {
      var l = o.graphQLErrors[v];
      if (l.path && l.path.length) {
        if (!s.__internal.errorMap) {
          s.__internal.errorMap = Object.create(null);
        }
        s.__internal.errorMap[l.path.join(".")] = l;
      }
    }
  }
  return s;
};

var updateContext = (e, r, t, i, a, n) => {
  V.current = e;
  e.parent = r;
  e.parentTypeName = t;
  e.parentKey = i;
  e.parentFieldKey = a;
  e.fieldName = n;
  e.error = getFieldError(e);
};

var isFragmentHeuristicallyMatching = (e, r, t, i) => {
  if (!r) {
    return !1;
  }
  var a = getTypeCondition(e);
  if (!a || r === a) {
    return !0;
  }
  "production" !== process.env.NODE_ENV && warn("Heuristic Fragment Matching: A fragment is trying to match against the `" + r + "` type, but the type condition is `" + a + "`. Since GraphQL allows for interfaces `" + a + "` may be aninterface.\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!", 16);
  return "write" === O || !getSelectionSet(e).some((e => {
    if (!isFieldNode(e)) {
      return !1;
    }
    var r = keyOfField(getName(e), getFieldArguments(e, i));
    return !((e, r) => void 0 !== readRecord(e, r) || void 0 !== readLink(e, r))(t, r);
  }));
};

var makeSelectionIterator = (e, r, t, i) => {
  var a = !1;
  var n;
  var o = 0;
  return function next() {
    if (!q.current && a) {
      q.current = a;
    }
    if (n) {
      var s = n();
      if (null != s) {
        return s;
      }
      n = void 0;
      a = !1;
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    }
    while (o < t.length) {
      var v = t[o++];
      if (!shouldInclude(v, i.variables)) {
        continue;
      } else if (!isFieldNode(v)) {
        var l = !isInlineFragment(v) ? i.fragments[getName(v)] : v;
        if (void 0 !== l) {
          if (i.store.schema ? isInterfaceOfType(i.store.schema, l, e) : isFragmentHeuristicallyMatching(l, e, r, i.variables)) {
            if ("production" !== process.env.NODE_ENV) {
              pushDebugNode(e, l);
            }
            a = !!isDeferred(v, i.variables);
            if (!q.current && a) {
              q.current = a;
            }
            return (n = makeSelectionIterator(e, r, getSelectionSet(l), i))();
          }
        }
      } else {
        return v;
      }
    }
  };
};

var ensureData = e => null == e ? null : e;

var ensureLink = (e, r) => {
  if (null == r) {
    return r;
  } else if (Array.isArray(r)) {
    var t = new Array(r.length);
    for (var i = 0, a = t.length; i < a; i++) {
      t[i] = ensureLink(e, r[i]);
    }
    return t;
  }
  var n = e.keyOfEntity(r);
  if ("production" !== process.env.NODE_ENV) {
    if (!n && r && "object" == typeof r) {
      warn("Can't generate a key for link(...) item.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + r.__typename + "`.", 12);
    }
  }
  return n;
};

var write = (e, r, t, i, a) => {
  initDataState("write", e.data, a || null);
  var n = startWrite(e, r, t, i);
  clearDataState();
  return n;
};

var startWrite = (e, r, t, i, a) => {
  var n = getMainOperation(r.query);
  var o = {
    data: t,
    dependencies: getCurrentDependencies()
  };
  var s = e.rootFields[n.operation];
  var v = makeContext(e, normalizeVariables(n, r.variables), getFragments(r.query), s, s, !!a, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(s, n);
  }
  writeSelection(v, s, getSelectionSet(n), t);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return o;
};

var writeSelection = (e, r, t, i) => {
  var a = r === e.store.rootFields.query;
  var n = !a && !!e.store.rootNames[r];
  var o = n || a ? r : i.__typename;
  if (!o) {
    "production" !== process.env.NODE_ENV && warn("Couldn't find __typename when writing.\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.", 14);
    return;
  } else if (!n && !a && r) {
    writeRecord(r, "__typename", o);
  }
  var s = makeSelectionIterator(o, r || o, t, e);
  var v;
  while (v = s()) {
    var l = getName(v);
    var u = getFieldArguments(v, e.variables);
    var d = keyOfField(l, u);
    var p = getFieldAlias(v);
    var c = i[e.optimistic ? l : p];
    if ("production" !== process.env.NODE_ENV) {
      if (!n && void 0 === c && !q.current && !e.optimistic) {
        "production" !== process.env.NODE_ENV && warn("Invalid undefined: The field at `" + d + "` is `undefined`, but the GraphQL query expects a " + (void 0 === v.selectionSet ? "scalar (number, boolean, etc)" : "selection set") + " for this field.", 13);
        continue;
      } else if (e.store.schema && o && "__typename" !== l) {
        isFieldAvailableOnType(e.store.schema, o, l);
      }
    }
    if ("__typename" === l || void 0 === c && q.current) {
      continue;
    }
    e.__internal.path.push(p);
    var f = void 0;
    if (e.optimistic && n) {
      if (!(f = e.store.optimisticMutations[l])) {
        continue;
      }
    } else if (e.optimistic && "function" == typeof c) {
      f = c;
    }
    if (f) {
      updateContext(e, i, o, o, d, l);
      c = ensureData(f(u || {}, e.store, e));
    }
    if (v.selectionSet) {
      if (r && !n) {
        var y = joinKeys(r, d);
        var h = writeField(e, getSelectionSet(v), ensureData(c), y);
        writeLink(r || o, d, h);
      } else {
        writeField(e, getSelectionSet(v), ensureData(c));
      }
    } else if (r && !n) {
      writeRecord(r || o, d, null !== c || !getFieldError(e) ? c : void 0);
    }
    if (n) {
      var m = e.store.updates[o][l];
      if (m) {
        updateContext(e, i, o, o, joinKeys(o, d), l);
        i[l] = c;
        m(i, u || {}, e.store, e);
      }
    }
    e.__internal.path.pop();
  }
};

var x = /^__|PageInfo|(Connection|Edge)$/;

var writeField = (e, r, t, i) => {
  if (Array.isArray(t)) {
    var a = new Array(t.length);
    for (var n = 0, o = t.length; n < o; n++) {
      e.__internal.path.push(n);
      var s = i ? joinKeys(i, `${n}`) : void 0;
      var v = writeField(e, r, t[n], s);
      a[n] = v;
      e.__internal.path.pop();
    }
    return a;
  } else if (null === t) {
    return getFieldError(e) ? void 0 : null;
  }
  var l = e.store.keyOfEntity(t);
  var u = t.__typename;
  if ("production" !== process.env.NODE_ENV) {
    if (i && !e.store.keys[t.__typename] && null === l && "string" == typeof u && !x.test(u)) {
      warn("Invalid key: The GraphQL query at the field at `" + i + "` has a selection set, but no key could be generated for the data at this field.\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `" + u + "`.\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `" + u + "` that always returns null.", 15);
    }
  }
  var d = l || i;
  writeSelection(e, d, r, t);
  return d || null;
};

class Store {
  constructor(e) {
    Store.prototype.__init.call(this);
    Store.prototype.__init2.call(this);
    if (!e) {
      e = {};
    }
    this.resolvers = e.resolvers || {};
    this.optimisticMutations = e.optimistic || {};
    this.keys = e.keys || {};
    var r = "Query";
    var t = "Mutation";
    var i = "Subscription";
    if (e.schema) {
      var a = (({__schema: e}) => {
        var r = new Map;
        var buildNameMap = e => {
          var r;
          return () => {
            if (!r) {
              r = {};
              for (var t = 0; t < e.length; t++) {
                r[e[t].name] = e[t];
              }
            }
            return r;
          };
        };
        var buildType = e => {
          switch (e.kind) {
           case "OBJECT":
           case "INTERFACE":
            return {
              name: e.name,
              kind: e.kind,
              interfaces: buildNameMap(e.interfaces || []),
              fields: buildNameMap(e.fields.map((e => ({
                name: e.name,
                type: e.type,
                args: buildNameMap(e.args)
              }))))
            };

           case "UNION":
            return {
              name: e.name,
              kind: e.kind,
              types: buildNameMap(e.possibleTypes || [])
            };
          }
        };
        var t = {
          query: e.queryType ? e.queryType.name : null,
          mutation: e.mutationType ? e.mutationType.name : null,
          subscription: e.subscriptionType ? e.subscriptionType.name : null,
          types: void 0,
          isSubType(e, t) {
            var i = r.get(e);
            var a = r.get(t);
            if (!i || !a) {
              return !1;
            } else if ("UNION" === i.kind) {
              return !!i.types()[t];
            } else if ("OBJECT" !== i.kind && "OBJECT" === a.kind) {
              return !!a.interfaces()[e];
            } else {
              return e === t;
            }
          }
        };
        if (e.types) {
          t.types = r;
          for (var i = 0; i < e.types.length; i++) {
            var a = e.types[i];
            if (a && a.name) {
              var n = buildType(a);
              if (n) {
                r.set(a.name, n);
              }
            }
          }
        }
        return t;
      })(e.schema);
      r = a.query || r;
      t = a.mutation || t;
      i = a.subscription || i;
      if (a.types) {
        this.schema = a;
      }
    }
    this.updates = {
      [t]: e.updates && e.updates.Mutation || {},
      [i]: e.updates && e.updates.Subscription || {}
    };
    this.rootFields = {
      query: r,
      mutation: t,
      subscription: i
    };
    this.rootNames = {
      [r]: "query",
      [t]: "mutation",
      [i]: "subscription"
    };
    this.data = (n = r, {
      defer: !1,
      gc: new Set,
      persist: new Set,
      queryRootKey: n,
      refCount: new Map,
      refLock: new Map,
      links: {
        optimistic: new Map,
        base: new Map
      },
      records: {
        optimistic: new Map,
        base: new Map
      },
      deferredKeys: new Set,
      commutativeKeys: new Set,
      optimisticOrder: [],
      storage: null
    });
    var n;
    if (this.schema && "production" !== process.env.NODE_ENV) {
      !function expectValidKeyingConfig(e, r) {
        if ("production" !== process.env.NODE_ENV) {
          for (var t in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!e.types.has(t)) {
                warn("Invalid Object type: The type `" + t + "` is not an object in the defined schema, but the `keys` option is referencing it.", 20);
              }
            }
          }
        }
      }(this.schema, this.keys);
      !function expectValidUpdatesConfig(e, r) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        if (e.mutation) {
          var t = e.types.get(e.mutation).fields();
          var i = r[e.mutation] || {};
          for (var a in i) {
            if ("production" !== process.env.NODE_ENV) {
              if (void 0 === t[a]) {
                warn("Invalid mutation field: `" + a + "` is not in the defined schema, but the `updates.Mutation` option is referencing it.", 21);
              }
            }
          }
        }
        if (e.subscription) {
          var n = e.types.get(e.subscription).fields();
          var o = r[e.subscription] || {};
          for (var s in o) {
            if ("production" !== process.env.NODE_ENV) {
              if (void 0 === n[s]) {
                warn("Invalid subscription field: `" + s + "` is not in the defined schema, but the `updates.Subscription` option is referencing it.", 22);
              }
            }
          }
        }
      }(this.schema, this.updates);
      !function expectValidResolversConfig(e, r) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        for (var t in r) {
          if ("Query" === t) {
            if (e.query) {
              var i = e.types.get(e.query).fields();
              for (var a in r.Query) {
                if (!i[a]) {
                  warnAboutResolver("Query." + a);
                }
              }
            } else {
              warnAboutResolver("Query");
            }
          } else if (!e.types.has(t)) {
            warnAboutResolver(t);
          } else if ("INTERFACE" === e.types.get(t).kind || "UNION" === e.types.get(t).kind) {
            s = t, v = e.types.get(t).kind, "production" !== process.env.NODE_ENV && warn(`Invalid resolver: \`${s}\` does not match to a concrete type in the schema, but the \`resolvers\` option is referencing it. Implement the resolver for the types that ${"UNION" === v ? "make up the union" : "implement the interface"} instead.`, 26);
          } else {
            var n = e.types.get(t).fields();
            for (var o in r[t]) {
              if (!n[o]) {
                warnAboutResolver(t + "." + o);
              }
            }
          }
        }
        var s, v;
      }(this.schema, this.resolvers);
      !function expectValidOptimisticMutationsConfig(e, r) {
        if ("production" === process.env.NODE_ENV) {
          return;
        }
        if (e.mutation) {
          var t = e.types.get(e.mutation).fields();
          for (var i in r) {
            if ("production" !== process.env.NODE_ENV) {
              if (!t[i]) {
                warn(`Invalid optimistic mutation field: \`${i}\` is not a mutation field in the defined schema, but the \`optimistic\` option is referencing it.`, 24);
              }
            }
          }
        }
      }(this.schema, this.optimisticMutations);
    }
  }
  __init() {
    this.keyOfField = keyOfField;
  }
  keyOfEntity(e) {
    if (V.current && e === V.current.parent) {
      return V.current.parentKey;
    }
    if (null == e || "string" == typeof e) {
      return e || null;
    }
    if (!e.__typename) {
      return null;
    }
    if (this.rootNames[e.__typename]) {
      return e.__typename;
    }
    var r;
    if (this.keys[e.__typename]) {
      r = this.keys[e.__typename](e);
    } else if (null != e.id) {
      r = `${e.id}`;
    } else if (null != e._id) {
      r = `${e._id}`;
    }
    return r ? `${e.__typename}:${r}` : null;
  }
  resolve(e, r, t) {
    var i = keyOfField(r, t);
    var a = this.keyOfEntity(e);
    if (!a) {
      return null;
    }
    var n = readRecord(a, i);
    if (void 0 !== n) {
      return n;
    }
    return readLink(a, i) || null;
  }
  __init2() {
    this.resolveFieldByKey = this.resolve;
  }
  invalidate(e, r, t) {
    var i = this.keyOfEntity(e);
    invariant(i, "production" !== process.env.NODE_ENV ? "Can't generate a key for invalidate(...).\nYou have to pass an id or _id field or create a custom `keys` field for `" + typeof e == "object" ? e.__typename : e + "`." : "", 19);
    ((e, r, t) => {
      var i = r ? [ {
        fieldKey: keyOfField(r, t)
      } ] : inspectFields(e);
      for (var a = 0, n = i.length; a < n; a++) {
        var {fieldKey: o} = i[a];
        if (void 0 !== readLink(e, o)) {
          writeLink(e, o, void 0);
        } else {
          writeRecord(e, o, void 0);
        }
      }
    })(i, r, t);
  }
  inspectFields(e) {
    var r = this.keyOfEntity(e);
    return r ? inspectFields(r) : [];
  }
  updateQuery(e, i) {
    var a = r(e.query, e.variables);
    a.query = t(a.query);
    var n = i(this.readQuery(a));
    if (null !== n) {
      startWrite(this, a, n);
    }
  }
  readQuery(e) {
    var i = r(e.query, e.variables);
    i.query = t(i.query);
    return read(this, i).data;
  }
  readFragment(e, r, i, a) {
    return readFragment(this, t(e), r, i, a);
  }
  writeFragment(e, r, i, a) {
    ((e, r, t, i, a) => {
      var n = getFragments(r);
      var o;
      if (a) {
        if (!(o = n[a])) {
          "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with a fragment name that does not exist.\nYou provided " + a + " but could only find " + Object.keys(n).join(", ") + ".", 11);
          return null;
        }
      } else if (!(o = n[Object.keys(n)[0]])) {
        "production" !== process.env.NODE_ENV && warn("writeFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 11);
        return null;
      }
      var s = getFragmentTypeName(o);
      var v = {
        __typename: s,
        ...t
      };
      var l = e.keyOfEntity(v);
      if (!l) {
        return "production" !== process.env.NODE_ENV ? warn("Can't generate a key for writeFragment(...) data.\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 12) : void 0;
      }
      if ("production" !== process.env.NODE_ENV) {
        pushDebugNode(s, o);
      }
      var u = makeContext(e, i || {}, n, s, l, void 0);
      writeSelection(u, l, getSelectionSet(o), v);
      if ("production" !== process.env.NODE_ENV) {
        popDebugNode();
      }
    })(this, t(e), r, i, a);
  }
  link(e, r, t, i) {
    var a = void 0 !== i ? t : null;
    var n = void 0 !== i ? i : t;
    var o = ensureLink(this, e);
    if ("string" == typeof o) {
      writeLink(o, keyOfField(r, a), ensureLink(this, n));
    }
  }
}

var query = (e, r, t, i, a) => {
  initDataState("read", e.data, a);
  var n = read(e, r, t, i);
  clearDataState();
  return n;
};

var read = (e, r, t, i) => {
  var a = getMainOperation(r.query);
  var n = e.rootFields[a.operation];
  var o = getSelectionSet(a);
  var s = makeContext(e, normalizeVariables(a, r.variables), getFragments(r.query), n, n, !1, i);
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(n, a);
  }
  if (!t) {
    t = makeData();
  }
  var v = n !== s.store.rootFields.query ? readRoot(s, n, o, t) : readSelection(s, n, o, t);
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return {
    dependencies: getCurrentDependencies(),
    partial: s.partial || !v,
    data: v || null
  };
};

var readRoot = (e, r, t, i) => {
  if ("string" != typeof (e.store.rootNames[r] ? r : i.__typename)) {
    return i;
  }
  var a = makeSelectionIterator(r, r, t, e);
  var n;
  var o = !1;
  var s = makeData(i);
  while (n = a()) {
    var v = getFieldAlias(n);
    var l = i[v];
    e.__internal.path.push(v);
    var u = void 0;
    if (n.selectionSet && null !== l) {
      u = readRootField(e, getSelectionSet(n), ensureData(l));
    } else {
      u = l;
    }
    o = o || u !== l;
    if (void 0 !== u) {
      s[v] = u;
    }
    e.__internal.path.pop();
  }
  return o ? s : i;
};

var readRootField = (e, r, t) => {
  if (Array.isArray(t)) {
    var i = new Array(t.length);
    var a = !1;
    for (var n = 0, o = t.length; n < o; n++) {
      e.__internal.path.push(n);
      i[n] = readRootField(e, r, t[n]);
      a = a || i[n] !== t[n];
      e.__internal.path.pop();
    }
    return a ? i : t;
  } else if (null === t) {
    return null;
  }
  var s = e.store.keyOfEntity(t);
  if (null !== s) {
    return readSelection(e, s, r, t) || null;
  } else {
    return readRoot(e, t.__typename, r, t);
  }
};

var readFragment = (e, r, t, i, a) => {
  var n = getFragments(r);
  var o;
  if (a) {
    if (!(o = n[a])) {
      "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with a fragment name that does not exist.\nYou provided " + a + " but could only find " + Object.keys(n).join(", ") + ".", 6);
      return null;
    }
  } else {
    if (!(o = n[Object.keys(n)[0]])) {
      "production" !== process.env.NODE_ENV && warn("readFragment(...) was called with an empty fragment.\nYou have to call it with at least one fragment in your GraphQL document.", 6);
      return null;
    }
  }
  var s = getFragmentTypeName(o);
  if ("string" != typeof t && !t.__typename) {
    t.__typename = s;
  }
  var v = e.keyOfEntity(t);
  if (!v) {
    "production" !== process.env.NODE_ENV && warn("Can't generate a key for readFragment(...).\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `" + s + "`.", 7);
    return null;
  }
  if ("production" !== process.env.NODE_ENV) {
    pushDebugNode(s, o);
  }
  var l = makeContext(e, i || {}, n, s, v);
  var u = readSelection(l, v, getSelectionSet(o), makeData()) || null;
  if ("production" !== process.env.NODE_ENV) {
    popDebugNode();
  }
  return u;
};

var readSelection = (e, r, t, i, a) => {
  var {store: n} = e;
  var o = r === n.rootFields.query;
  var s = a && n.keyOfEntity(a) || r;
  if ("production" !== process.env.NODE_ENV) {
    if (!o && e.store.rootNames[s]) {
      warn("Invalid root traversal: A selection was being read on `" + s + "` which is an uncached root type.\nThe `" + e.store.rootFields.mutation + "` and `" + e.store.rootFields.subscription + "` types are special Operation Root Types and cannot be read back from the cache.", 25);
    }
  }
  var v = !o ? readRecord(s, "__typename") || a && a.__typename : r;
  if ("string" != typeof v) {
    return;
  } else if (a && v !== a.__typename) {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver data: The resolver at `" + s + "` returned an invalid typename that could not be reconciled with the cache.", 8);
    return;
  }
  var l = makeSelectionIterator(v, s, t, e);
  var u = !1;
  var d = !1;
  var p = v !== i.__typename;
  var c;
  var f = makeData(i);
  while (void 0 !== (c = l())) {
    var y = getName(c);
    var h = getFieldArguments(c, e.variables);
    var m = getFieldAlias(c);
    var _ = keyOfField(y, h);
    var g = joinKeys(s, _);
    var N = readRecord(s, _);
    var E = a ? a[y] : void 0;
    var O = n.resolvers[v];
    if ("production" !== process.env.NODE_ENV && n.schema && v) {
      isFieldAvailableOnType(n.schema, v, y);
    }
    e.__internal.path.push(m);
    var k = void 0;
    if ("__typename" === y) {
      k = v;
    } else if (void 0 !== E && void 0 === c.selectionSet) {
      k = E;
    } else if ("read" === getCurrentOperation() && O && "function" == typeof O[y]) {
      updateContext(e, f, v, s, g, y);
      if (void 0 !== N) {
        f[m] = N;
      }
      k = O[y](f, h || {}, n, e);
      if (c.selectionSet) {
        k = resolveResolverResult(e, v, y, g, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], k, ownsData(i));
      }
      if (n.schema && null === k && !isFieldNullable(n.schema, v, y)) {
        return;
      }
    } else if (!c.selectionSet) {
      k = N;
    } else if (void 0 !== E) {
      k = resolveResolverResult(e, v, y, g, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], E, ownsData(i));
    } else {
      var w = readLink(s, _);
      if (void 0 !== w) {
        k = resolveLink(e, w, v, y, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], ownsData(i));
      } else if ("object" == typeof N && null !== N) {
        k = N;
      }
    }
    if (void 0 === k && q.current) {
      u = !0;
    } else if (void 0 === k && (n.schema && isFieldNullable(n.schema, v, y) || getFieldError(e))) {
      d = !0;
      k = null;
    } else if (void 0 === k) {
      e.__internal.path.pop();
      return;
    } else {
      u = u || "__typename" !== y;
    }
    e.__internal.path.pop();
    p = p || k !== i[m];
    if (void 0 !== k) {
      f[m] = k;
    }
  }
  e.partial = e.partial || d;
  return o && d && !u ? void 0 : p ? f : i;
};

var resolveResolverResult = (e, r, t, i, a, n, o, s) => {
  if (Array.isArray(o)) {
    var {store: v} = e;
    var l = v.schema ? isListNullable(v.schema, r, t) : !1;
    var u = new Array(o.length);
    var d = !Array.isArray(n) || o.length !== n.length;
    for (var p = 0, c = o.length; p < c; p++) {
      e.__internal.path.push(p);
      var f = resolveResolverResult(e, r, t, joinKeys(i, `${p}`), a, null != n ? n[p] : void 0, o[p], s);
      e.__internal.path.pop();
      if (void 0 === f && !l) {
        return;
      } else {
        e.partial = e.partial || void 0 === f && l;
        u[p] = null != f ? f : null;
        d = d || u[p] !== n[p];
      }
    }
    return d ? u : n;
  } else if (null == o) {
    return o;
  } else if (s && null === n) {
    return null;
  } else if (isDataOrKey(o)) {
    var y = n || makeData();
    return "string" == typeof o ? readSelection(e, o, a, y) : readSelection(e, i, a, y, o);
  } else {
    "production" !== process.env.NODE_ENV && warn("Invalid resolver value: The field at `" + i + "` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.", 9);
    return;
  }
};

var resolveLink = (e, r, t, i, a, n, o) => {
  if (Array.isArray(r)) {
    var {store: s} = e;
    var v = s.schema ? isListNullable(s.schema, t, i) : !1;
    var l = new Array(r.length);
    var u = !Array.isArray(n) || l.length !== n.length;
    for (var d = 0, p = r.length; d < p; d++) {
      e.__internal.path.push(d);
      var c = resolveLink(e, r[d], t, i, a, null != n ? n[d] : void 0, o);
      e.__internal.path.pop();
      if (void 0 === c && !v) {
        return;
      } else {
        e.partial = e.partial || void 0 === c && v;
        l[d] = c || null;
        u = u || l[d] !== n[d];
      }
    }
    return u ? l : n;
  } else if (null === r || null === n && o) {
    return null;
  }
  return readSelection(e, r, a, n || makeData());
};

var isDataOrKey = e => "string" == typeof e || "object" == typeof e && "string" == typeof e.__typename;

var addCacheOutcome = (e, r) => i(e.kind, e, {
  ...e.context,
  meta: {
    ...e.context.meta,
    cacheOutcome: r
  }
});

var toRequestPolicy = (e, r) => i(e.kind, e, {
  ...e.context,
  requestPolicy: r
});

var cacheExchange = e => ({forward: r, client: d, dispatchDebug: p}) => {
  var c = new Store(e);
  if (e && e.storage) {
    e.storage.readData().then((r => {
      ((e, r, t) => {
        initDataState("write", e, null);
        for (var i in t) {
          var a = t[i];
          if (void 0 !== a) {
            var {entityKey: n, fieldKey: o} = deserializeKeyInfo(i);
            if (":" === a[0]) {
              if (void 0 === readLink(n, o)) {
                writeLink(n, o, JSON.parse(a.slice(1)));
              }
            } else if (void 0 === readRecord(n, o)) {
              writeRecord(n, o, JSON.parse(a));
            }
          }
        }
        clearDataState();
        e.storage = r;
      })(c.data, e.storage, r);
    }));
  }
  var f = new Map;
  var y = [];
  var h = new Map;
  var m = new Map;
  var _ = new Set;
  var g = new Set;
  var N = new Map;
  var isBlockedByOptimisticUpdate = e => {
    for (var r of e.values()) {
      if (_.has(r)) {
        return !0;
      }
    }
    return !1;
  };
  var collectPendingOperations = (e, r) => {
    if (r) {
      for (var t of r.values()) {
        var i = N.get(t);
        if (i) {
          for (var a of i.values()) {
            e.add(a);
          }
        }
      }
    }
  };
  var executePendingOperations = (e, r) => {
    for (var t of r.values()) {
      if (t !== e.key) {
        var i = h.get(t);
        if (i) {
          h.delete(t);
          var a = "cache-first";
          if (g.has(t)) {
            g.delete(t);
            a = "cache-and-network";
          }
          d.reexecuteOperation(toRequestPolicy(i, a));
        }
      }
    }
  };
  var prepareForwardedOperation = e => {
    if ("query" === e.kind) {
      reserveLayer(c.data, e.key);
    } else if ("teardown" === e.kind) {
      h.delete(e.key);
      m.delete(e.key);
      noopDataState(c.data, e.key);
    } else if ("mutation" === e.kind && "network-only" !== e.context.requestPolicy) {
      var {dependencies: r} = ((e, r, t) => {
        if ("production" !== process.env.NODE_ENV) {
          invariant("mutation" === getMainOperation(r.query).operation, "production" !== process.env.NODE_ENV ? "writeOptimistic(...) was called with an operation that is not a mutation.\nThis case is unsupported and should never occur." : "", 10);
        }
        initDataState("write", e.data, t, !0);
        var i = startWrite(e, r, {}, void 0, !0);
        clearDataState();
        return i;
      })(c, e, e.key);
      if (r.size) {
        for (var a of r.values()) {
          _.add(a);
        }
        f.set(e.key, r);
        var n = new Set;
        collectPendingOperations(n, r);
        executePendingOperations(e, n);
      }
    }
    return i(e.kind, {
      key: e.key,
      query: t(e.query),
      variables: e.variables ? filterVariables(getMainOperation(e.query), e.variables) : e.variables
    }, e.context);
  };
  var updateDependencies = (e, r) => {
    for (var t of r.values()) {
      var i = N.get(t);
      if (!i) {
        N.set(t, i = new Set);
      }
      i.add(e.key);
      h.set(e.key, e);
    }
  };
  var operationResultFromCache = e => {
    var r = query(c, e, m.get(e.key));
    var t = r.data ? !r.partial ? "hit" : "partial" : "miss";
    m.set(e.key, r.data);
    updateDependencies(e, r.dependencies);
    return {
      outcome: t,
      operation: e,
      data: r.data,
      dependencies: r.dependencies
    };
  };
  var updateCacheWithResult = (e, r) => {
    var {operation: t, error: i, extensions: a} = e;
    var {key: n} = t;
    if ("mutation" === t.kind) {
      var o = f.get(n);
      collectPendingOperations(r, o);
      f.delete(n);
    }
    reserveLayer(c.data, t.key, "subscription" === t.kind || e.hasNext);
    var s;
    var v = e.data;
    if (v) {
      var l = write(c, t, v, e.error, n).dependencies;
      collectPendingOperations(r, l);
      var u = query(c, t, "query" === t.kind ? m.get(t.key) || v : v, e.error, n);
      v = u.data;
      if ("query" === t.kind) {
        collectPendingOperations(r, s = u.dependencies);
        m.set(t.key, e.data);
      }
    } else {
      noopDataState(c.data, t.key);
    }
    if (s) {
      updateDependencies(e.operation, s);
    }
    return {
      data: v,
      error: i,
      extensions: a,
      operation: t
    };
  };
  return e => {
    var t = a(e);
    var i = a(n(operationResultFromCache)(o((e => "query" === e.kind && "network-only" !== e.context.requestPolicy))(t)));
    var h = o((e => "query" !== e.kind || "network-only" === e.context.requestPolicy))(t);
    var m = n((e => {
      "production" !== process.env.NODE_ENV && p({
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache",
        operation: e.operation,
        source: "cacheExchange"
      });
      return addCacheOutcome(e.operation, "miss");
    }))(o((e => "miss" === e.outcome && "cache-only" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies)))(i));
    var N = n((e => {
      var {operation: r, outcome: t, dependencies: i} = e;
      var a = {
        operation: addCacheOutcome(r, t),
        data: e.data,
        error: e.error,
        extensions: e.extensions
      };
      if ("cache-and-network" === r.context.requestPolicy || "cache-first" === r.context.requestPolicy && "partial" === t) {
        a.stale = !0;
        if (!isBlockedByOptimisticUpdate(i)) {
          d.reexecuteOperation(toRequestPolicy(r, "network-only"));
        } else if ("cache-and-network" === r.context.requestPolicy) {
          g.add(r.key);
        }
      }
      "production" !== process.env.NODE_ENV && p({
        type: "cacheHit",
        message: "A requested operation was found and returned from the cache.",
        operation: e.operation,
        data: {
          value: a
        },
        source: "cacheExchange"
      });
      return a;
    }))(o((e => "miss" !== e.outcome || "cache-only" === e.operation.context.requestPolicy))(i));
    var E = a(r(n(prepareForwardedOperation)(s([ h, m ]))));
    var O = n((e => {
      var r = new Set;
      var t = updateCacheWithResult(e, r);
      executePendingOperations(e.operation, r);
      return t;
    }))(o((e => !f.has(e.operation.key)))(E));
    var k = v((e => {
      if (y.push(e) < f.size) {
        return l;
      }
      for (var r = 0; r < y.length; r++) {
        reserveLayer(c.data, y[r].operation.key);
      }
      _.clear();
      var t = [];
      var i = new Set;
      var a;
      while (a = y.shift()) {
        t.push(updateCacheWithResult(a, i));
      }
      executePendingOperations(e.operation, i);
      return u(t);
    }))(o((e => f.has(e.operation.key)))(E));
    return s([ O, k, N ]);
  };
};

var isOfflineError = e => e && e.networkError && !e.response && ("undefined" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\s?error/i.test(e.networkError.message));

var offlineExchange = e => t => {
  var {storage: n} = e;
  if (n && n.onOnline && n.readMetadata && n.writeMetadata) {
    var {forward: v, client: l, dispatchDebug: u} = t;
    var {source: c, next: f} = d();
    var h = e.optimistic || {};
    var m = [];
    var updateMetadata = () => {
      var e = [];
      for (var r = 0; r < m.length; r++) {
        var t = m[r];
        if ("mutation" === t.kind) {
          e.push({
            query: y(t.query),
            variables: t.variables
          });
        }
      }
      n.writeMetadata(e);
    };
    var _ = !1;
    var flushQueue = () => {
      if (!_) {
        _ = !0;
        for (var e = 0; e < m.length; e++) {
          var r = m[e];
          if ("mutation" === r.kind) {
            f(i("teardown", r));
          }
        }
        for (var t = 0; t < m.length; t++) {
          l.reexecuteOperation(m[t]);
        }
        m.length = 0;
        _ = !1;
        updateMetadata();
      }
    };
    n.onOnline(flushQueue);
    n.readMetadata().then((e => {
      if (e) {
        for (var t = 0; t < e.length; t++) {
          m.push(l.createRequestOperation("mutation", r(e[t].query, e[t].variables)));
        }
        flushQueue();
      }
    }));
    var g = cacheExchange({
      ...e,
      storage: {
        ...n,
        readData: () => n.readData().finally(flushQueue)
      }
    })({
      client: l,
      dispatchDebug: u,
      forward: e => o((e => {
        if ("mutation" === e.operation.kind && isOfflineError(e.error) && ((e, r) => {
          var t = r.variables || {};
          var i = getFragments(r.query);
          var a = [ ...getSelectionSet(getMainOperation(r.query)) ];
          var n;
          while (n = a.pop()) {
            if (!shouldInclude(n, t)) {
              continue;
            } else if (!isFieldNode(n)) {
              var o = !isInlineFragment(n) ? i[getName(n)] : n;
              if (o) {
                a.push(...getSelectionSet(o));
              }
            } else if (e[getName(n)]) {
              return !0;
            }
          }
          return !1;
        })(h, e.operation)) {
          m.push(N.get(e.operation.context._instance) || e.operation);
          updateMetadata();
          return !1;
        }
        if ("mutation" === e.operation.kind && !e.error) {
          N.delete(e.operation.context._instance);
        }
        return !0;
      }))(v(e))
    });
    var N = new WeakMap;
    return e => {
      var r = a(p((e => {
        if ("mutation" === e.kind) {
          N.set(e.context._instance, e);
        }
      }))(e));
      var t = s([ c, r ]);
      return o((e => {
        if ("query" === e.operation.kind && isOfflineError(e.error)) {
          f(toRequestPolicy(e.operation, "cache-only"));
          m.push(e.operation);
          return !1;
        }
        return !0;
      }))(g(t));
    };
  }
  return cacheExchange(e)(t);
};

export { Store, cacheExchange, offlineExchange, query, write };
//# sourceMappingURL=urql-exchange-graphcache.mjs.map
